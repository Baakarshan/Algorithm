# Merging Intervals

🧠 算法介绍
本算法用于解决一维区间覆盖问题，旨在找出多个区间合并后的最长连续覆盖段和最长未覆盖的间隙。

**核心思想**是**贪心算法**，通过对所有时间区间进行排序和合并来实现。
1.  **排序**：首先，将所有农夫的工作时间区间 `[start, end]` 按照 `start` 时间点从小到大进行排序。这使得我们可以按时间顺序线性地处理所有区间。
2.  **合并**：排序后，我们遍历这些区间。维护一个当前正在形成的“连续挤奶时间段”，记为 `[current_start, current_end]`。
    *   如果下一个区间与当前连续时间段有重叠（即 `next_interval.start <= current_end`），说明挤奶没有中断，我们将当前连续时间段的结束时间更新为 `max(current_end, next_interval.end)`，从而将两个区间合并。
    *   如果下一个区间与当前连续时间段没有重叠（即 `next_interval.start > current_end`），说明上一个连续的挤奶时间段已经结束。此时，我们计算刚刚结束的这个时间段的长度，并更新“最长挤奶时间”。同时，`current_end` 和 `next_interval.start` 之间形成了一个“无人挤奶”的间隙，我们也计算其长度并更新“最长无人时间”。然后，用下一个区间开启一个新的连续挤奶时间段。
3.  **遍历结束后**，不要忘记处理最后一个正在形成的连续挤奶时间段。

*   **时间复杂度**：O(N log N)，主要由对 N 个区间的排序操作决定。排序后的合并过程是线性的 O(N)。
*   **空间复杂度**：O(N)，用于存储 N 个区间。如果可以原地排序，则为 O(log N) 或 O(1)，取决于排序算法的实现。

🔍 实现思路
1.  **数据结构设计**：
    *   使用 `struct` 或 `std::pair<int, int>` 来表示每个农夫的工作时间区间 `[start, end]`。
    *   使用 `std::vector` 来存储所有的 `N` 个时间区间。
    *   使用 `long long` 类型的变量来存储最长挤奶时间和最长无人时间，以避免潜在的整数溢出（虽然在本题数据范围内 `int` 足够，但 `long long` 是更稳妥的选择）。

2.  **算法流程**：
    *   **步骤一：输入与排序**
        *   读取农夫数量 `N`。如果 `N` 为 0，直接输出 `0 0`。
        *   循环读取 `N` 个时间区间并存入 `vector`。
        *   对 `vector` 中的所有区间按 `start` 时间进行升序排序。
    *   **步骤二：初始化**
        *   初始化 `max_milking_time = 0` 和 `max_idle_time = 0`。
        *   将第一个区间 `intervals[0]` 作为初始的连续挤奶段，即 `current_start = intervals[0].start` 和 `current_end = intervals[0].end`。
    *   **步骤三：遍历与合并**
        *   从第二个区间（索引为 1）开始遍历。
        *   对于每个区间 `intervals[i]`：
            *   **重叠情况**：如果 `intervals[i].start <= current_end`，则合并区间，更新 `current_end = std::max(current_end, intervals[i].end)`。
            *   **间隙情况**：如果 `intervals[i].start > current_end`：
                1.  一个连续挤奶段结束了。计算其长度 `current_end - current_start`，并更新 `max_milking_time`。
                2.  一个无人时段出现了。计算其长度 `intervals[i].start - current_end`，并更新 `max_idle_time`。
                3.  开启一个新的连续挤奶段：`current_start = intervals[i].start`, `current_end = intervals[i].end`。
    *   **步骤四：处理最后一个区间**
        *   循环结束后，最后一个形成的连续挤奶段 `[current_start, current_end]` 尚未被计算。计算其长度 `current_end - current_start` 并更新 `max_milking_time`。
    *   **步骤五：输出结果**
        *   输出 `max_milking_time` 和 `max_idle_time`。

3.  **复杂度分析**：
    *   **时间复杂度**：O(N log N) for sorting, O(N) for merging. Total: O(N log N).
    *   **空间复杂度**：O(N) to store the intervals.

💻 C++11 实现代码
```cpp
#include <iostream> // 引入输入输出流库
#include <vector>   // 引入动态数组 vector
#include <algorithm>// 引入算法库，主要是为了 sort 和 max

// 定义一个结构体来表示时间区间，比 std::pair 更具可读性
struct Interval {
    int start; // 区间开始时间
    int end;   // 区间结束时间
};

// 用于 std::sort 的自定义比较函数
bool compareIntervals(const Interval& a, const Interval& b) {
    return a.start < b.start; // 按开始时间升序排序
}

// main 函数是程序的入口点
int main() {
    // 使用 std::ios_base::sync_with_stdio(false) 和 std::cin.tie(NULL) 来加速 C++ 的 I/O 操作
    std::ios_base::sync_with_stdio(false); // 关闭 C++ 流与 C 标准流的同步
    std::cin.tie(NULL); // 解除 cin 和 cout 的绑定

    int n; // 声明一个整数 n，用于存储农夫的数量
    std::cin >> n; // 从标准输入读取 n

    // 如果没有农夫，则最长时间都为 0
    if (n == 0) {
        std::cout << "0 0" << std::endl;
        return 0; // 程序正常结束
    }

    std::vector<Interval> intervals(n); // 创建一个大小为 n 的 vector 存储所有时间区间
    for (int i = 0; i < n; ++i) { // 循环 n 次读取每个区间
        std::cin >> intervals[i].start >> intervals[i].end; // 将读取的起止时间存入 vector
    }

    // 步骤一：对所有区间按开始时间进行排序
    std::sort(intervals.begin(), intervals.end(), compareIntervals);

    // 步骤二：初始化变量
    long long max_milking_time = 0; // 最长连续挤奶时间
    long long max_idle_time = 0;    // 最长连续无人时间

    // 将第一个区间作为当前合并区间的起点
    int current_start = intervals[0].start;
    int current_end = intervals[0].end;

    // 步骤三：从第二个区间开始遍历并合并
    for (int i = 1; i < n; ++i) {
        if (intervals[i].start <= current_end) {
            // 情况一：当前区间与正在合并的区间有重叠
            // 扩展合并区间的结束时间
            current_end = std::max(current_end, intervals[i].end);
        } else {
            // 情况二：当前区间与正在合并的区间有间隙
            // 1. 结算上一个合并区间的长度
            max_milking_time = std::max(max_milking_time, (long long)current_end - current_start);
            // 2. 计算并更新最长间隙时间
            max_idle_time = std::max(max_idle_time, (long long)intervals[i].start - current_end);
            // 3. 开启一个新的合并区间
            current_start = intervals[i].start;
            current_end = intervals[i].end;
        }
    }

    // 步骤四：处理最后一个合并的区间
    // 循环结束后，最后一个合并区间还没有被结算
    max_milking_time = std::max(max_milking_time, (long long)current_end - current_start);

    // 步骤五：输出结果
    std::cout << max_milking_time << " " << max_idle_time << std::endl;

    return 0; // 程序正常结束
}
```
