# Greedy Propagation on Deficit Array

🧠 算法介绍
本算法通过将回文匹配问题转化为一个“赤字填补”问题，并使用贪心策略来求得最小操作次数。

**核心思想**：
1.  **赤字数组构建**：我们不再直接处理原数组 `a` 或其差分。我们创建一个“赤字”数组 `b`，其大小与 `a` 相同并初始化为0。对于每一对需要匹配的对称元素 `a[i]` 和 `a[n-1-i]`，如果它们不相等，说明其中一个需要增加。我们把需要增加的量记录在 `b` 数组的对应位置。例如，如果 `a[i] < a[n-1-i]`，则 `a[i]` 需要增加 `a[n-1-i] - a[i]`，我们就令 `b[i] = a[n-1-i] - a[i]`。这样，原问题就转化为：用最小的操作次数，满足 `b` 数组中记录的所有增加量。

2.  **贪心策略**：我们有两种操作来满足 `b[i]` 的赤字（即增加 `a[i]`）：
    *   **单点操作**：只对 `a[i]` 操作，代价为1，满足 `b[i]` 的1个单位赤字。
    *   **邻接操作**：对相邻的 `a[i]` 和 `a[i+1]` 同时操作，代价为1，同时满足 `b[i]` 和 `b[i+1]` 的各1个单位赤字。
    显然，如果 `b[i]` 和 `b[i+1]` 都有赤字，优先使用邻接操作是更优的。这形成了贪心策略的基础：从左到右遍历赤字数组 `b`。在第 `i` 步，我们优先使用邻接操作来同时满足 `b[i]` 和 `b[i+1]` 的共同赤字部分。对于 `b[i]` 剩下的赤字，由于我们不再回溯，只能用单点操作来满足。

3.  **代价计算**：
    *   在第 `i` 步，`b[i]` 和 `b[i+1]` 的共同赤字是 `min(b[i], b[i+1])`。我们执行这么多次邻接操作，代价为 `min(b[i], b[i+1])`，并将其累加到总代价中。
    *   执行后，`b[i]` 的剩余赤字必须由单点操作满足，代价为 `b[i] - min(b[i], b[i+1])`。也将其累加。
    *   `b[i+1]` 的赤字被更新，并带入到下一步 `i+1` 的计算中。
    *   这个过程一直持续到数组末尾。

时间复杂度：O(N)，用于构建赤字数组和一次线性遍历。
空间复杂度：O(N)，用于存储赤字数组。

🔍 实现思路
1.  **数据结构设计**：
    *   使用 `std::vector<long long>` 存储输入的数组 `a`。为方便对称索引，采用0-based索引。
    *   创建一个大小与 `a` 相同的 `std::vector<long long>` `b`，并初始化为全0，用于存储赤字。
    *   使用 `long long` 类型的变量 `total_cost` 累计总操作次数。

2.  **算法流程**：
    *   **步骤一**：读取整数 `n` 和数组 `a` 的 `n` 个元素。
    *   **步骤二**：构建赤字数组 `b`。遍历 `i` 从 `0` 到 `n/2 - 1`：
        *   比较 `a[i]` 和 `a[n-1-i]`。
        *   如果 `a[i] < a[n-1-i]`，则在 `b[i]` 处记录赤字：`b[i] = a[n-1-i] - a[i]`。
        *   如果 `a[i] > a[n-1-i]`，则在 `b[n-1-i]` 处记录赤字：`b[n-1-i] = a[i] - a[n-1-i]`。
    *   **步骤三**：贪心计算总代价。遍历 `i` 从 `0` 到 `n-2`（因为我们每次看 `i` 和 `i+1`）：
        *   计算 `b[i]` 和 `b[i+1]` 的共同赤字：`common_deficit = std::min(b[i], b[i+1])`。
        *   这部分共同赤字通过邻接操作满足，代价为 `common_deficit`。将其累加到 `total_cost`。
        *   更新赤字数组：`b[i] -= common_deficit`，`b[i+1] -= common_deficit`。
        *   此时 `b[i]` 的赤字必须通过单点操作满足（因为我们不再回看 `i-1`），其代价为 `b[i]` 的剩余值。将其累加到 `total_cost`。
    *   **步骤四**：处理最后一个元素的赤字。循环结束后，`b[n-1]` 可能还有剩余赤字，这部分只能通过单点操作满足。将其累加到 `total_cost`。
    *   **步骤五**：输出 `total_cost`。

3.  **复杂度分析**：
    *   **时间复杂度**：读取输入 O(N)，构建赤字数组 O(N)，贪心遍历 O(N)。总时间复杂度为 O(N)。
    *   **空间复杂度**：存储输入数组 `a` 和赤字数组 `b` 都需要 O(N) 空间。总空间复杂度为 O(N)。

💻 C++11 实现代码
```cpp
#include <iostream> // 引入输入输出流库
#include <vector>   // 引入动态数组 vector
#include <algorithm>// 引入算法库，主要是为了 min

// main 函数是程序的入口点
int main() {
    // 使用 std::ios_base::sync_with_stdio(false) 和 std::cin.tie(NULL) 来加速 C++ 的 I/O 操作
    std::ios_base::sync_with_stdio(false); // 关闭 C++ 流与 C 标准流的同步
    std::cin.tie(NULL); // 解除 cin 和 cout 的绑定

    int n; // 声明一个整数变量 n，用于存储数组的大小
    std::cin >> n; // 从标准输入读取数组大小 n

    std::vector<long long> a(n); // 声明一个 long long 类型的 vector a，大小为 n，用于存储输入的数组元素
    for (int i = 0; i < n; ++i) { // 循环 n 次，读取数组的每个元素
        std::cin >> a[i]; // 读取第 i 个元素并存入 vector a
    }

    // 创建赤字数组 b，大小为 n，并初始化所有元素为 0
    std::vector<long long> b(n, 0); // 使用 long long 防止溢出
    for (int i = 0; i < n / 2; ++i) { // 遍历数组的一半来比较对称元素
        if (a[i] < a[n - 1 - i]) { // 如果左边的元素较小
            b[i] = a[n - 1 - i] - a[i]; // 在左边位置记录需要增加的量（赤字）
        } else if (a[i] > a[n - 1 - i]) { // 如果右边的元素较小
            b[n - 1 - i] = a[i] - a[n - 1 - i]; // 在右边位置记录需要增加的量（赤字）
        }
    }

    long long total_cost = 0; // 声明一个 long long 变量用于累计总操作次数
    
    // 贪心策略：从左到右处理赤字数组
    for (int i = 0; i < n - 1; ++i) { // 遍历到倒数第二个元素
        // 1. 邻接操作：优先处理 b[i] 和 b[i+1] 的共同赤字
        long long common_deficit = std::min(b[i], b[i+1]); // 计算可以一起处理的赤字量
        total_cost += common_deficit; // 共同赤字的成本就是其本身，累加到总成本
        b[i] -= common_deficit; // 从 b[i] 中减去已处理的部分
        b[i+1] -= common_deficit; // 从 b[i+1] 中减去已处理的部分

        // 2. 单点操作：处理 b[i] 的剩余赤字
        total_cost += b[i]; // b[i] 剩下的部分只能通过单点操作满足，成本就是其数值
        // b[i] 的任务到此结束，其值现在逻辑上为0
    }

    // 循环结束后，最后一个元素 b[n-1] 的剩余赤字只能由单点操作满足
    total_cost += b[n - 1]; // 将最后一个元素的成本加入总成本

    std::cout << total_cost << std::endl; // 输出最终计算出的最小总操作次数

    return 0; // 程序正常结束
}
```
