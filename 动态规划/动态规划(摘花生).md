我们要解决的问题是：

> Hello Kitty 在一片花生地中只能向右或向下移动，每到一个位置能采集该位置的花生，求她从左上角到右下角过程中能采到的最大花生数量。

---

## 🧠 问题分析（简要概述）

这是一道典型的 **二维动态规划问题**。
类似于“走格子收获最大值”的模型。

---

### ✅ 状态表示：

* 用 `f[i][j]` 表示从起点 `(0,0)` 到达位置 `(i,j)` 所能摘到的最多花生数。

---

### ✅ 状态转移方程：

到达 `(i,j)` 的路径有两种方式：

* 从上方 `(i-1,j)` 来：`f[i][j] = f[i-1][j] + w[i][j]`
* 从左边 `(i,j-1)` 来：`f[i][j] = f[i][j-1] + w[i][j]`

综上：

```cpp
f[i][j] = max(f[i-1][j], f[i][j-1]) + w[i][j];
```

---

## ✅ C++ 实现（含详细中文注释，使用 `using namespace std;`）

```cpp
#include <iostream>     // 输入输出库
#include <algorithm>    // max 函数
using namespace std;    // 使用标准命名空间

const int N = 110;      // 最大行列数 100，预留空间

int w[N][N];            // 存储花生田里每个位置的花生数
int f[N][N];            // f[i][j] 表示走到(i,j)时最多摘到的花生数

int main() {
    int T;
    cin >> T;           // 读入测试数据组数

    while (T--) {
        int R, C;
        cin >> R >> C;  // 读入每组的行数和列数

        // 读入花生田的每一格花生数量
        for (int i = 1; i <= R; ++i)
            for (int j = 1; j <= C; ++j)
                cin >> w[i][j];

        // 动态规划初始化与转移
        for (int i = 1; i <= R; ++i) {
            for (int j = 1; j <= C; ++j) {
                // 状态转移方程：当前最多花生数来自上面或左边最大者 + 当前花生
                f[i][j] = max(f[i - 1][j], f[i][j - 1]) + w[i][j];
            }
        }

        // 输出每组的结果：到达(R,C)位置的最大花生数
        cout << f[R][C] << endl;
    }

    return 0;
}
```

---

## 📌 输入示例解释：

输入：

```
2
2 2
1 1
3 4
2 3
2 3 4
1 6 5
```

### 第1组地图：

```
1 1
3 4
```

最优路径：1 → 1 → 4，共摘：1+1+4+2 = **8**

### 第2组地图：

```
2 3 4
1 6 5
```

最优路径：2 → 3 → 4 → 5，共摘：**16**

---

## ✅ 输出：

```
8
16
```

---
