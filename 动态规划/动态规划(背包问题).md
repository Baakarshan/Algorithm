我们要解决的问题是典型的：

> **01背包问题**：给定 $N$ 件物品和容量为 $V$ 的背包，每个物品只能选一次，求最大价值。

---

## 🧠 问题简要概述

* 有 `N` 件物品；
* 每件物品有两个属性：`体积 vi`、`价值 wi`；
* 背包最大容量为 `V`；
* 目标是在容量不超出 `V` 的前提下，选择一些物品使得**总价值最大**。

这是一个经典的 **动态规划（DP）问题**。

---

## ✅ 解题思路（动态规划）

### ✅ 状态定义：

我们用一维数组：

```cpp
f[v]：表示容量为 v 的背包，能达到的最大价值
```

### ✅ 状态转移公式（核心）：

遍历每件物品，倒序更新容量：

```cpp
for (int i = 1; i <= N; ++i)         // 遍历物品
    for (int j = V; j >= v[i]; --j)  // 容量从 V 到 v[i] 倒序遍历
        f[j] = max(f[j], f[j - v[i]] + w[i]);
```

为什么倒序？因为每件物品**只能用一次**（01背包），防止被重复计算。

---

## ✅ C++ 实现（使用 `using namespace std;`，逐行中文注释）

```cpp
#include <iostream>     // 输入输出流
#include <algorithm>    // 提供 max 函数
using namespace std;    // 使用标准命名空间，避免写 std::

const int N = 1010;     // N最大为1000，预留空间

int f[N];               // f[j] 表示容量为 j 时的最大价值
int v[N], w[N];         // v[i] 表示第 i 件物品的体积，w[i] 表示其价值

int main() {
    int n, V;
    cin >> n >> V;      // 输入物品数量和背包容量

    // 读入每件物品的体积和价值
    for (int i = 1; i <= n; ++i) {
        cin >> v[i] >> w[i];
    }

    // 动态规划求解01背包
    for (int i = 1; i <= n; ++i) {           // 遍历所有物品
        for (int j = V; j >= v[i]; --j) {    // 背包容量从大到小遍历（倒序）
            f[j] = max(f[j], f[j - v[i]] + w[i]); // 状态转移：不选 or 选当前物品
        }
    }

    cout << f[V] << endl;    // 输出最终最大价值
    return 0;
}
```

---

## 📌 示例说明

输入：

```
4 5
1 2
2 4
3 4
4 5
```

表示有 4 件物品，背包容量为 5。每件物品的体积和价值如下：

| 物品 | 体积 | 价值 |
| -- | -- | -- |
| 1  | 1  | 2  |
| 2  | 2  | 4  |
| 3  | 3  | 4  |
| 4  | 4  | 5  |

选择物品 1 和 2，体积 1+2=3，总价值 6；
选择物品 2 和 3，体积 2+3=5，总价值 **8** ← ✅最大值

输出：

```
8
```

---

## ✅ 小结

| 项目    | 内容              |
| ----- | --------------- |
| 问题类型  | 动态规划 - 01背包问题   |
| 时间复杂度 | $O(N \times V)$ |
| 空间优化  | 使用一维数组 + 倒序     |
| 注意    | 每个物品只能选一次       |

---
