我们要解决的是：

> **完全背包问题**：每种物品可以选无限次，在不超过容量 V 的前提下，使总价值最大。

---

## 🧠 问题简要说明

与 01 背包的唯一区别：

* **01背包**：每种物品只能用一次 → 倒序遍历容量；
* ✅ **完全背包**：每种物品可以用无限次 → 顺序遍历容量！

---

## ✅ 状态设计（DP）

定义：

```cpp
f[j] 表示容量为 j 时的最大价值
```

状态转移方程（顺序遍历）：

```cpp
f[j] = max(f[j], f[j - vi] + wi);  // 可多次使用物品 i
```

---

## ✅ C++ 实现（详细注释、标准格式）

```cpp
#include <iostream>     // 输入输出流
#include <algorithm>    // 提供 max 函数
using namespace std;    // 使用标准命名空间

const int N = 1010;     // 最大物品数或容量为1000

int f[N];               // f[j] 表示容量为 j 时的最大价值
int v[N], w[N];         // v[i] 表示第 i 种物品体积，w[i] 表示其价值

int main() {
    int n, V;
    cin >> n >> V;      // 读入物品种数和背包总容量

    // 读入每种物品的体积和价值
    for (int i = 1; i <= n; ++i) {
        cin >> v[i] >> w[i];
    }

    // 完全背包：正序遍历容量
    for (int i = 1; i <= n; ++i) {         // 遍历每种物品
        for (int j = v[i]; j <= V; ++j) {  // 容量从 v[i] 到 V 正序遍历
            f[j] = max(f[j], f[j - v[i]] + w[i]); // 选 or 不选当前物品
        }
    }

    cout << f[V] << endl;    // 输出最大价值
    return 0;
}
```

---

## 🔁 示例讲解

输入：

```
4 5
1 2
2 4
3 4
4 5
```

含义：

| 物品 | 体积 | 价值 |
| -- | -- | -- |
| 1  | 1  | 2  |
| 2  | 2  | 4  |
| 3  | 3  | 4  |
| 4  | 4  | 5  |

目标是选无限多物品，不超过体积 5，最大价值是多少？

答案：

* 选两个体积为 2 的物品（4 + 4）+ 体积 1 的（2） = 10 ← ✅最优

---

## ✅ 小结

| 项目    | 内容                  |
| ----- | ------------------- |
| 问题类型  | 动态规划 - 完全背包问题       |
| 状态设计  | f\[j] = 容量为 j 的最大价值 |
| 时间复杂度 | $O(N \times V)$     |
| 遍历方向  | **正序**（每件物品可选无限次）   |

---
