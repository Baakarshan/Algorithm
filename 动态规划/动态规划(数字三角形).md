我们要解决的问题是：

> 在一个数字三角形中，从顶部出发，每次只能走到下一层的左下或右下位置，求一条路径，使得路径上的数字和最大。

---

## 🧠 问题分析（简要概述）

这是一个典型的 **动态规划（Dynamic Programming）** 问题。

### 核心思想：

我们从三角形**底部向上倒推**，每个点都选择其下面左右两个点中较大的那一个，加到当前点上，最终顶点即为最大路径和。

---

## ✅ C++ 实现（使用 `using namespace std;`，每行加详细中文注释）

```cpp
#include <iostream>     // 用于输入输出
#include <algorithm>    // 用于 max 函数
using namespace std;    // 使用标准命名空间，避免写 std::

const int N = 510;      // 最大层数为500，预留空间
int a[N][N];            // 存储原始数字三角形
int f[N][N];            // f[i][j] 表示从(i,j)到底部的最大路径和

int main() {
    int n;
    cin >> n;           // 读入三角形层数

    // 读入三角形中的所有数
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j <= i; ++j) {
            cin >> a[i][j];      // 第 i 行 j 列的数字
        }
    }

    // 初始化最底层：f[n-1][j] = a[n-1][j]
    for (int j = 0; j < n; ++j) {
        f[n - 1][j] = a[n - 1][j];   // 底层值直接拷贝
    }

    // 从倒数第二层往上推，每个点选下方左右较大的路径
    for (int i = n - 2; i >= 0; --i) {       // 从第 n-2 层开始
        for (int j = 0; j <= i; ++j) {
            f[i][j] = max(f[i + 1][j], f[i + 1][j + 1]) + a[i][j];
            // 当前值 = max(左下, 右下) + 当前节点值
        }
    }

    // 顶点 f[0][0] 就是最大路径和
    cout << f[0][0] << endl;

    return 0;
}
```

---

## 🔁 示例运行流程说明（可视化）

输入：

```
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
```

倒推过程如下（从底层往上）：

```text
层4:    4   5   2   6   5          ← 初始化
层3:  2+5 7+5 4+6 4+6 = 7 12 10 10
层2: 8+12 1+10 0+10   = 20 11 10
层1: 3+20 8+11         = 23 19
层0: 7+23              = 30
```

输出：

```
30
```

---

## 📌 时间复杂度

* 读入：O(n²)
* 递推：O(n²)
* 总体效率非常高，支持到 500 层以内三角形。

---
