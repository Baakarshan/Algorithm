我们要解决的问题是：

> **多重背包问题（Multiple Knapsack）**：每种物品最多有 $s_i$ 件，每件体积为 $v_i$、价值为 $w_i$，选若干件装进容量为 $V$ 的背包，求最大价值。

---

## 🧠 问题简要概述

多重背包是 01 背包（只能选 1 次）和 完全背包（可无限选） 的结合体：

* 每种物品最多可以选择 `s[i]` 次；
* 不能无限取，也不能只取 1 次。

---

## ✅ 方法一：**朴素做法：三重循环**

我们可以直接套用三重循环：

1. 枚举每种物品；
2. 枚举背包容量（从大到小）；
3. 枚举取几件该物品 $k = 1~s_i$，只要容量够。

时间复杂度是 $O(N \times V \times S_{\max})$，当数据较小时可用。

---

## ✅ C++ 实现（详细注释，使用 `using namespace std`）

```cpp
#include <iostream>     // 用于输入输出
#include <algorithm>    // 用于 max 函数
using namespace std;    // 使用标准命名空间

const int N = 110;      // 最大物品种类数、背包容量

int f[N];               // f[j] 表示容量为 j 的最大价值
int v[N], w[N], s[N];   // v[i] 体积，w[i] 价值，s[i] 数量上限

int main() {
    int n, V;
    cin >> n >> V;                  // 读入物品种数 n 和背包容量 V

    for (int i = 1; i <= n; ++i) {
        cin >> v[i] >> w[i] >> s[i];  // 读入每个物品的体积、价值、最大数量
    }

    // 动态规划三重循环
    for (int i = 1; i <= n; ++i) {          // 遍历每种物品
        for (int j = V; j >= 0; --j) {      // 背包容量从大到小倒序遍历（01背包）
            for (int k = 1; k <= s[i]; ++k) { // 枚举当前物品取几件（最多 s[i] 件）
                if (j >= k * v[i]) {        // 如果容量足够
                    f[j] = max(f[j], f[j - k * v[i]] + k * w[i]);
                } else break;              // 如果容量不够，提前结束（剪枝）
            }
        }
    }

    cout << f[V] << endl;   // 输出最大价值
    return 0;
}
```

---

## ✅ 输入样例分析

输入：

```
4 5
1 2 3
2 4 1
3 4 3
4 5 2
```

表示：

* 容量 = 5
* 第 1 种：体积 1，价值 2，最多 3 件
* 第 2 种：体积 2，价值 4，最多 1 件
* 第 3 种：体积 3，价值 4，最多 3 件
* 第 4 种：体积 4，价值 5，最多 2 件

**最优方案**：选 2 件第 1 种（2×2=4）+ 第 3 种 1 件（3×1=3），共体积 = 2+3=5，价值 = 4+6=10。

输出：

```
10
```

---

## ✅ 小结

| 项目    | 内容                            |
| ----- | ----------------------------- |
| 状态定义  | `f[j]`：容量为 j 时的最大价值           |
| 状态转移  | 遍历所有可能的物品数量，进行更新              |
| 遍历方式  | 倒序（防止重复使用）                    |
| 时间复杂度 | $O(N \cdot V \cdot S_{\max})$ |
| 优化方案  | 二进制优化（把 s 拆成 log(s) 件）        |

---
