我们要解决的是一个经典的**方格取数两次路径最大和问题**，是动态规划中非常有代表性的一个模型。

---

## 🧠 问题简述

给定一个 $N \times N$ 的方格图，一些格子中有正整数，其他为 0。一个人从左上角 `(1,1)` 走到右下角 `(N,N)` 两次（只能向右或向下），每次都可以收集路径上的数字（一次收集就变成0）。求这两次路径加起来**最多能收集多少数字之和**。

---

## ✅ 解题思路（文字说明）

### ✅ 本质分析：

* 本题难点在于：不能简单地做两次 DP，因为第一次路径不知道怎么选，第二次路径会受到第一次路径“清空数字”的影响。
* 所以我们使用一个非常巧妙的转换思路：

> **把两次路径同时进行建模**，让两个人同时从 `(1,1)` 走到 `(N,N)`，每次两人都只能向下或向右移动。

### ✅ 状态定义（核心）：

我们设：

```cpp
f[x1][y1][x2] = 第一个人到 (x1,y1)，第二个人到 (x2,y2)，能取得的最大数字和
```

由于两人走了相同步数 `k = x1 + y1 = x2 + y2`，所以 `y2 = k - x2`，不需要再单独记录 `y2`。

### ✅ 状态转移：

两人可以各自选择“向下”或“向右”，所以共有 4 种组合：

* 都向下
* 一人向下，一人向右（两种）
* 都向右

用四种转移更新：

```cpp
f[x1][y1][x2] = max(
    f[x1-1][y1][x2-1],
    f[x1][y1-1][x2],
    f[x1-1][y1][x2],
    f[x1][y1-1][x2-1]
) + 当前格子的值
```

注意：

* 如果两人落在同一个格子，只取一次该格子的值；
* 所有边界处理要注意不越界。

---

## ✅ C++ 实现（详细中文注释、使用 `using namespace std`）

```cpp
#include <iostream>
#include <cstring>  // 用于 memset 初始化
#include <algorithm>
using namespace std;

const int N = 11;

int w[N][N];           // 存储原始地图上每个格子的数值
int f[N][N][N];        // 状态：f[x1][y1][x2]，y2 = x1 + y1 - x2

int main() {
    int n;
    cin >> n;

    // 输入数值
    while (true) {
        int x, y, v;
        cin >> x >> y >> v;
        if (x == 0 && y == 0 && v == 0) break;
        w[x][y] = v;  // 注意下标从1开始
    }

    // 初始化 DP 状态
    for (int k = 2; k <= n * 2; ++k) {
        for (int x1 = 1; x1 <= n; ++x1) {
            for (int x2 = 1; x2 <= n; ++x2) {
                int y1 = k - x1;  // y1 = 总步数 - x1
                int y2 = k - x2;  // 同理 y2

                // 坐标不合法则跳过
                if (y1 < 1 || y1 > n || y2 < 1 || y2 > n) continue;

                // 转移方程，四种走法组合
                int& val = f[x1][y1][x2];
                val = max({
                    f[x1 - 1][y1][x2 - 1],
                    f[x1 - 1][y1][x2],
                    f[x1][y1 - 1][x2 - 1],
                    f[x1][y1 - 1][x2]
                });

                // 当前两人所在格子的得分（如果坐标相同，只加一次）
                val += (x1 == x2 && y1 == y2) ? w[x1][y1] : w[x1][y1] + w[x2][y2];
            }
        }
    }

    // 输出终点位置的结果
    cout << f[n][n][n] << endl;
    return 0;
}
```

---

## 🧪 示例运行说明

输入：

```
8
2 3 13
2 6 6
3 5 7
4 4 14
5 2 21
5 6 4
6 3 15
7 2 14
0 0 0
```

输出：

```
67
```

表示从 `(1,1)` 出发走两次，最多能获得 `67` 分。

---

## ✅ 总结

| 技术点      | 说明                        |
| -------- | ------------------------- |
| 多维 DP 建模 | 三维 DP 结合两个路径状态            |
| 状态压缩技巧   | 利用 x1+x2 = x2+x2 限制减少一个维度 |
| 转移方式     | 枚举四种路径组合                  |
| 注意事项     | 两人走到同一格只加一次价值             |

---
