# Sliding Window Maximum Sum

🧠 算法介绍
该算法用于解决一个博弈论问题，目标是找到玩家可以保证获得的最高分数。问题的核心在于，无论对手（墙体摧毁）如何行动，玩家总能完成一个特定长度的连续壁画。

**原理分析**：
玩家每天画一格，墙体每天被摧毁一格。总共 `N` 段墙，玩家最终能画的墙段数量为 `k = ⌈N/2⌉`。这是因为在 `m = ⌊N/2⌋` 天后，`m` 段墙被画，`m` 段墙被毁。如果 `N` 是偶数，游戏结束，玩家画了 `N/2` 段。如果 `N` 是奇数，还剩一段墙，玩家在下一天画上，总共画了 `(N+1)/2` 段。

**策略保证**：
玩家可以保证画出任意一个长度为 `k` 的连续子区域。策略是：选择一个目标连续子区域，第一天从该区域的一个端点开始画。之后每一天，都紧挨着已画好的部分、在目标区域内继续作画。由于墙体只能从整个未毁区域的两端被摧毁，对手永远无法“跳入”中间来破坏玩家的目标区域。玩家画画的速度（每天一格向内）和墙体被摧毁的速度（每天一格向外）相同，足以让玩家完成他选定的 `k` 格连续壁画。

**问题转化**：
既然玩家可以保证画出任意一个长度为 `k` 的连续区域，为了保证获得的分数最大化，他应该选择所有长度为 `k` 的连续子区域中，美观分总和最高的那一个。问题因此转化为：**求解一个固定长度 `k` 的滑动窗口内的最大和**。

**算法与复杂度**：
我们可以使用滑动窗口算法来解决。首先计算第一个长度为 `k` 的窗口的和，然后将窗口向右逐格滑动，每次滑动时，减去离开窗口的元素，加上进入窗口的元素，并持续更新最大和。
*   时间复杂度：O(N)，因为我们只需要对数组进行一次线性扫描。
*   空间复杂度：O(N) 或 O(1)，取决于是否将输入字符串预处理到整型数组中。如果直接在字符串上操作，额外空间是 O(1)。

🔍 实现思路
1.  **数据结构设计**：
    *   一个 `std::vector<int>` 用来存储从输入字符串转换来的每段墙的美观评分。
    *   使用 `long long` 类型的变量来存储当前的窗口和以及历史最大和，以防止潜在的整数溢出（虽然在本题数据范围下 `int` 可能也够用，但 `long long` 是更稳妥的选择）。

2.  **算法流程**：
    *   **主循环**：外层是一个循环，处理 `T` 组测试数据。
    *   **初始化**：对于每组测试数据，读取 `N` 和美观评分字符串。将字符串中的字符数字转换为整数并存入 `vector`。
    *   **计算窗口大小**：计算玩家能保证画出的墙段数 `k`。`k = (N + 1) / 2`，这利用了整数除法巧妙地实现了 `ceil(N/2)`。
    *   **滑动窗口**：
        1.  **创建第一个窗口**：计算前 `k` 个元素（即 `scores[0]` 到 `scores[k-1]`）的和。将这个和同时赋值给 `current_sum` 和 `max_sum`。
        2.  **滑动并更新**：从第 `k` 个元素开始遍历到数组末尾（即 `i` 从 `k` 到 `N-1`）。在每一步：
            *   更新 `current_sum`：减去滑出窗口的元素 `scores[i-k]`，并加上滑入窗口的新元素 `scores[i]`。
            *   更新 `max_sum`：将 `current_sum` 与当前的 `max_sum` 比较，取较大者。
    *   **输出结果**：遍历结束后，`max_sum` 就是能保证得到的最大美观总分。按照 "Case #x: y" 的格式输出。

3.  **复杂度分析**：
    *   **时间复杂度**：对于每组测试数据，转换字符串为 O(N)，计算初始窗口和为 O(k)，滑动窗口过程为 O(N-k)。总体上是 O(N)。`T` 组数据总共是 O(T * N)。
    *   **空间复杂度**：需要一个 O(N) 的 `vector` 来存储分数。因此空间复杂度为 O(N)。

💻 C++11 实现代码
```cpp
#include <iostream> // 引入输入输出流库
#include <vector>   // 引入动态数组 vector
#include <string>   // 引入字符串处理库
#include <numeric>  // 引入数值算法，例如 accumulate (虽然本代码未使用)
#include <algorithm>// 引入算法库，主要是为了 max

// solve 函数用于处理单个测试用例
void solve(int case_num) {
    int n; // 声明一个整数 n，用于存储墙的段数
    std::cin >> n; // 从标准输入读取 n
    std::string scores_str; // 声明一个字符串，用于存储美观评分
    std::cin >> scores_str; // 从标准输入读取美观评分字符串

    std::vector<int> scores; // 声明一个整型 vector，用于存储转换后的美观评分
    scores.reserve(n); // 预分配容量以提高效率
    for (char c : scores_str) { // 使用 C++11 的范围 for 循环遍历字符串中的每个字符
        scores.push_back(c - '0'); // 将字符数字转换为整数（例如 '3' -> 3）并存入 vector
    }

    // 计算玩家可以保证画出的墙段数 k，即 N/2 的向上取整
    int k = (n + 1) / 2; // (n+1)/2 是计算 ceil(n/2.0) 的整数运算技巧

    long long current_sum = 0; // 声明一个长整型变量，存储当前滑动窗口内分数的总和
    // 计算第一个窗口（前 k 个墙段）的总分
    for (int i = 0; i < k; ++i) { // 循环 k 次
        current_sum += scores[i]; // 累加分数
    }

    long long max_sum = current_sum; // 声明一个长整型变量，存储所有窗口中的最大总分，并用第一个窗口的和初始化

    // 开始滑动窗口
    // 从第 k 个元素开始，到最后一个元素结束
    for (int i = k; i < n; ++i) {
        // 窗口向右滑动一格：加上新进入的元素，减去滑出去的元素
        current_sum += scores[i] - scores[i - k];
        // 更新历史最大和
        max_sum = std::max(max_sum, current_sum); // 在当前最大值和新窗口和之间取较大者
    }

    // 按格式输出结果
    std::cout << "Case #" << case_num << ": " << max_sum << std::endl; // 输出案例编号和最终结果
}

// main 函数是程序的入口点
int main() {
    // 使用 std::ios_base::sync_with_stdio(false) 和 std::cin.tie(NULL) 来加速 C++ 的 I/O 操作
    std::ios_base::sync_with_stdio(false); // 关闭 C++ 流与 C 标准流的同步
    std::cin.tie(NULL); // 解除 cin 和 cout 的绑定

    int t; // 声明一个整数 t，用于存储测试数据的组数
    std::cin >> t; // 从标准输入读取 t
    for (int i = 1; i <= t; ++i) { // 循环 t 次，处理每组测试数据
        solve(i); // 调用 solve 函数处理第 i 组数据
    }

    return 0; // 程序正常结束
}
```
