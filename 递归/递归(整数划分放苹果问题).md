### 🧠 问题简述

这是一个**经典的“将苹果放进盘子里”的组合问题**：

* 有 `M` 个**相同的苹果**，
* 要放入 `N` 个**相同的盘子**中，
* **允许盘子为空**，
* 求不同的放法数（**顺序不重要**，所以 `(5,1,1)` 和 `(1,5,1)` 是同一种放法）。

---

### ✅ 思路分析：使用递归解决

我们用 `f(m, n)` 表示 `m` 个苹果放入 `n` 个盘子的**不同放法数**。

#### 📌 递归转移公式：

```
f(m, n) = f(m, n - 1) + f(m - n, n)      // n <= m
```

解释：

1. `f(m, n - 1)`：考虑至少有一个**空盘子**的情况（即我们不使用第 `n` 个盘子）；
2. `f(m - n, n)`：考虑**每个盘子至少放一个**苹果（先每盘一个，剩下的 `m - n` 个苹果再分）。

#### 📌 边界条件：

* 如果 `m == 0` 或 `n == 1`，则只有 1 种放法；
* 如果 `n == 0`，无法放，返回 0；
* 如果 `n > m`，多余的盘子没用，相当于 `f(m, m)`（多余盘子空着）；

---

### ✅ C++ 实现（每行都有详细注释）

```cpp
#include <iostream>
using namespace std;

// 定义一个递归函数，计算m个苹果放入n个盘子的放法数
int countWays(int m, int n) {
    if (m == 0 || n == 1) return 1; // 若苹果为0或只有一个盘子，只有1种方式
    if (n == 0) return 0;           // 没有盘子了，无法放苹果
    if (n > m) return countWays(m, m); // 盘子比苹果多，相当于只用前m个盘子
    return countWays(m, n - 1) + countWays(m - n, n); // 两种情况之和
}

int main() {
    int t; // 测试组数
    cin >> t;
    while (t--) {
        int m, n;
        cin >> m >> n;
        cout << countWays(m, n) << endl; // 输出每组数据的结果
    }
    return 0;
}
```

---

### 🧪 示例讲解

输入：

```
1
7 3
```

表示：7 个苹果，3 个盘子。

输出：

```
8
```

这 8 种放法为：

```
(7,0,0)
(6,1,0)
(5,2,0)
(5,1,1)
(4,3,0)
(4,2,1)
(3,3,1)
(3,2,2)
```

（注意顺序不重要，(6,1,0) 和 (1,6,0) 视为同一种）

---

### ✅ 总结

| 状态 `f(m, n)`  | 含义               |
| ------------- | ---------------- |
| `f(m, n - 1)` | 至少有一个盘子空         |
| `f(m - n, n)` | 每个盘子先放 1 个，剩下的再分 |

这是一个**典型的“整数划分”问题**，有递归、动态规划、记忆化搜索等多种优化方法。

---

## ✅ 方法一：**递归 + 记忆化搜索**（推荐）

原来的纯递归有很多重复计算，我们可以用二维数组记录每个 `(m, n)` 的计算结果，避免重复计算，显著加速。

### 🚀 代码如下（每行都有详细注释）：

```cpp
#include <iostream>
#include <cstring> // 用于 memset
using namespace std;

int memo[11][11]; // 备忘录数组，最多10个苹果和10个盘子（因为M,N <= 10）

// 递归函数，返回m个苹果放入n个盘子的方案数
int countWays(int m, int n) {
    if (m == 0 || n == 1) return 1;      // 苹果为0或盘子为1时，只有一种放法
    if (n == 0) return 0;                // 没有盘子时无法放置苹果
    if (memo[m][n] != -1) return memo[m][n]; // 如果之前计算过，直接返回
    if (n > m) return memo[m][n] = countWays(m, m); // 多余的盘子没用，相当于 f(m, m)

    // 两种选择的总和：
    // 1. 至少一个盘子空（不使用第n个盘子）
    // 2. 每个盘子至少一个苹果（先每个盘子放一个，再分剩下的）
    return memo[m][n] = countWays(m, n - 1) + countWays(m - n, n);
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        int m, n;
        cin >> m >> n;
        memset(memo, -1, sizeof(memo)); // 初始化备忘录数组为 -1
        cout << countWays(m, n) << endl;
    }
    return 0;
}
```

### ✅ 优点：

* 相比纯递归，速度快很多；
* 没有多余计算；
* 时间复杂度大约为 `O(m × n)`，非常快（这里 m,n ≤ 10）。

---

## ✅ 方法二：**动态规划（DP）**（完全消除递归）

我们用一个二维数组 `dp[i][j]` 表示 `i` 个苹果，放入 `j` 个盘子的放法数。

### 🚀 状态转移方程：

```cpp
dp[i][j] = dp[i][j - 1] + dp[i - j][j];   // i >= j
```

解释：

* `dp[i][j - 1]`: 至少一个盘子空；
* `dp[i - j][j]`: 每个盘子至少放一个苹果。

### 🌟 完整 DP 代码：

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int t;
    cin >> t;
    while (t--) {
        int m, n;
        cin >> m >> n;

        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0)); // dp数组初始化为0

        // 初始化：f(0,x) = 1 (0个苹果放x个盘子只有1种方式：啥都不放)
        for (int j = 0; j <= n; ++j) dp[0][j] = 1;

        // 开始动态规划填表
        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (j > i)
                    dp[i][j] = dp[i][i];           // 多余的盘子当成一样
                else
                    dp[i][j] = dp[i][j - 1] + dp[i - j][j]; // 状态转移
            }
        }

        cout << dp[m][n] << endl;
    }
    return 0;
}
```

---

## 🆚 对比总结

| 方法    | 递归     | 递归 + 记忆化 | 动态规划     |
| ----- | ------ | -------- | -------- |
| 编码复杂度 | 低      | 中        | 中高       |
| 时间复杂度 | 指数     | O(m × n) | O(m × n) |
| 空间复杂度 | O(m+n) | O(m × n) | O(m × n) |
| 运行效率  | 慢      | 快        | 快        |
| 推荐指数  | ⭐      | ⭐⭐⭐      | ⭐⭐⭐⭐     |

---

## 🧠 总结一句话：

> **小数据建议用记忆化递归（容易写），大数据建议用动态规划（更高效）！**
