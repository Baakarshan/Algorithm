### ✅ 问题简述

从 `1` 到 `n` 的整数中，**选出 `m` 个数的所有组合**，并按 **字典序** 输出每种方案。

---

### ✅ 解题思路（用 DFS 递归回溯 + 剪枝优化）

我们使用 **回溯法（DFS）** 解决组合问题。

每次尝试从当前数开始，依次往后选数加入组合中，直到组合长度达到 `m` 为止，就将其输出。

---

### ✅ C++ 代码（含每行中文注释）

```cpp
#include <iostream>
#include <vector>

using namespace std;

int n, m;             // 输入的 n 和 m
vector<int> path;     // 当前选择的组合

// 深度优先搜索，u 表示当前数字的起点
void dfs(int u) {
    // 如果组合长度为 m，说明找到一种合法方案，输出
    if (path.size() == m) {
        for (int i = 0; i < path.size(); i++) {
            if (i > 0) cout << " "; // 数字之间加空格
            cout << path[i];
        }
        cout << endl;
        return;
    }

    // 剪枝优化：剩余可选数不足以填满组合，则停止递归
    for (int i = u; i <= n - (m - path.size()) + 1; i++) {
        path.push_back(i);   // 选择当前数 i
        dfs(i + 1);          // 递归从下一个数开始
        path.pop_back();     // 回溯：撤销选择 i
    }
}

int main() {
    cin >> n >> m;  // 输入 n 和 m
    dfs(1);         // 从数字 1 开始递归
    return 0;
}
```

---

### ✅ 示例执行过程（以 `n=5, m=3` 为例）

调用树如下（简略版）：

```
dfs(1)
├── 选1 → dfs(2)
│   ├── 选2 → dfs(3)
│   │   ├── 选3 → 输出 1 2 3
│   │   ├── 选4 → 输出 1 2 4
│   │   └── 选5 → 输出 1 2 5
│   ├── 选3 → dfs(4)
│   │   ├── 选4 → 输出 1 3 4
│   │   └── 选5 → 输出 1 3 5
│   ├── 选4 → dfs(5)
│   │   └── 选5 → 输出 1 4 5
├── 选2 → dfs(3)
│   ├── 选3 → dfs(4)
│   │   ├── 选4 → 输出 2 3 4
│   │   └── 选5 → 输出 2 3 5
│   └── 选4 → dfs(5)
│       └── 选5 → 输出 2 4 5
├── 选3 → dfs(4)
│   └── 选4 → dfs(5)
│       └── 选5 → 输出 3 4 5
```

---

### ✅ 小结

* 思路：用 DFS 遍历所有组合；
* 保证升序 & 无重复：每次递归只往后选择；
* 剪枝条件：`i <= n - (m - 当前已选数量) + 1`

---

