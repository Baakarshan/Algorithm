### 🧠 问题简述

林克面对一座有 `N` 级台阶的天梯，他每次可以走 **1级** 或 **2级**。
他想知道：从地面走到顶端，一共有多少种不同的走法？

---

### ✅ 这是经典的“斐波那契数列”问题！

我们记：

* `f(n)` 表示爬到第 `n` 级台阶的走法总数。

递推关系：

```
f(n) = f(n - 1) + f(n - 2)
```

解释：

* 到达第 `n` 级台阶的最后一步：

  * 要么是从 `n - 1` 级走一级；
  * 要么是从 `n - 2` 级走两级；
* 所以总走法数是两者之和。

初始条件：

```
f(0) = 1  // 没有台阶也算一种“啥也不做”的方式
f(1) = 1  // 只有一级台阶，只有一种跳法
```

---

### ✅ C++ 递归 + 记忆化版本（每行详细注释）

```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<long long> memo(47, -1);  // 用于记忆递归结果，最多到 f(46)，初始化为 -1

// 递归函数：计算第 n 级台阶的走法数
long long climb(int n) {
    if (memo[n] != -1) return memo[n];  // 如果之前算过，直接返回
    if (n == 0 || n == 1) return memo[n] = 1;  // 基本情况：f(0) = f(1) = 1
    return memo[n] = climb(n - 1) + climb(n - 2);  // 递归公式 f(n) = f(n-1) + f(n-2)
}

int main() {
    int n;
    cin >> n;           // 读取台阶数
    cout << climb(n);   // 输出走法数
    return 0;
}
```

---

### 🧪 示例解释

输入：

```
3
```

输出：

```
3
```

说明：

* 共三种走法：

  1. 1 + 1 + 1
  2. 1 + 2
  3. 2 + 1

---

### ✅ 小结

| 台阶数 N | 走法数        |
| ----- | ---------- |
| 0     | 1          |
| 1     | 1          |
| 2     | 2          |
| 3     | 3          |
| 4     | 5          |
| 5     | 8          |
| ...   | ...        |
| 46    | 1836311903 |

---
这个问题是经典的“斐波那契爬楼梯问题”，可以用多种方法解决，下面我给你按**从慢到快、从容易到难**的顺序列出常见解法，并说明每种的特点：

---

## ✅ 方法一：递归 + 记忆化（**推荐初学递归时使用**）

> 之前讲过，使用递归并缓存结果（避免重复计算）。

* **时间复杂度：O(n)**
* **空间复杂度：O(n)**（递归 + 记忆数组）

适合入门理解“递归的本质 + 状态转移”。

---

## ✅ 方法二：动态规划 DP（**最常见写法**）

我们只用一个 `dp[n+1]` 数组来记录每一级的走法。

### 🌟 C++ 动态规划代码：

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n;
    cin >> n;

    vector<long long> dp(n + 2); // 注意：要开 n+2 以防越界
    dp[0] = dp[1] = 1;           // 初始状态：f(0) = f(1) = 1

    for (int i = 2; i <= n; ++i) {
        dp[i] = dp[i - 1] + dp[i - 2];  // 状态转移方程
    }

    cout << dp[n] << endl;
    return 0;
}
```

* **时间复杂度：O(n)**
* **空间复杂度：O(n)**

---

## ✅ 方法三：动态规划 + 空间优化（**滚动变量法**）

> 因为每次只用到前两个数，所以可以用两个变量代替整个数组。

### 🌟 C++ 滚动变量代码：

```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;

    long long a = 1, b = 1;  // 初始化 f(0), f(1)
    for (int i = 2; i <= n; ++i) {
        long long c = a + b; // 当前走法是前两个走法之和
        a = b;               // 更新 f(n-2)
        b = c;               // 更新 f(n-1)
    }

    cout << b << endl;
    return 0;
}
```

* **时间复杂度：O(n)**
* **空间复杂度：O(1)**（只用了3个变量）

👍 这是**最简洁、最快速、最常用的写法**！

---

## ✅ 方法四：通项公式（**数学高阶解法**）

斐波那契数列有一个通项公式（Binet公式）：

$$
F(n) = \frac{1}{\sqrt{5}} \left[ \left( \frac{1 + \sqrt{5}}{2} \right)^n - \left( \frac{1 - \sqrt{5}}{2} \right)^n \right]
$$

* 不推荐在整数运算中使用，因为有精度误差。
* 若用于推导或数学证明非常有用。

---

## ✅ 方法五：矩阵快速幂（**竞赛常用，时间复杂度 O(logN)**）

这个方法把状态转移转化为矩阵乘法，可以在 `O(logN)` 时间内计算出第 `n` 项。

也就是：

$$
\begin{bmatrix} F(n) \\ F(n-1) \end{bmatrix}
=
\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}^{n-1}
\times
\begin{bmatrix} F(1) \\ F(0) \end{bmatrix}
$$

这个方法比较复杂，如果你想挑战高级算法我可以帮你写出来并详细解释。

---

## ✅ 总结对比

| 方法       | 时间复杂度    | 空间复杂度 | 适合人群     |
| -------- | -------- | ----- | -------- |
| 递归 + 记忆化 | O(n)     | O(n)  | 初学者、理解递归 |
| 动态规划数组版  | O(n)     | O(n)  | 初学 DP    |
| 动态规划滚动变量 | O(n)     | O(1)  | 推荐！      |
| 通项公式     | O(1)     | O(1)  | 数学推导使用   |
| 矩阵快速幂    | O(log n) | O(1)  | 算法竞赛选手   |

---
