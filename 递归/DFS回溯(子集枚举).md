### 🧠 问题简述

给定一个正整数 `n (1 ≤ n ≤ 15)`，你要从 `1 ~ n` 这 `n` 个整数中**任选若干个**（可以一个都不选），**输出所有可能的选择方案**。

* 每种方案是一个子集，子集内数字**升序排列**；
* 每行输出一个方案，不同方案行顺序**不要求固定**；
* 如果是“空集”，输出空行即可。

---

## ✅ 解题思路：回溯（DFS 构造所有子集）

我们可以用 **深度优先搜索**（递归）去枚举所有选择方案。

* 对于每一个数字 `i`，我们有两种选择：

  * **选它**
  * **不选它**
* 最后输出所有路径即可。

---

## ✅ C++ 实现（每行详细中文注释）

```cpp
#include <iostream>
#include <vector>
using namespace std;

int n;                      // 输入的上限值 n
vector<int> path;           // 当前构造的子集路径（选择了哪些数字）

// 递归函数，当前考虑从数字 u 开始选
void dfs(int u) {
    if (u > n) {
        // 已经遍历完所有数字，输出当前方案
        if (path.empty()) {
            cout << endl;  // 空集输出空行
        } else {
            for (int i = 0; i < path.size(); ++i) {
                if (i > 0) cout << " ";  // 数字之间加空格
                cout << path[i];         // 输出当前数字
            }
            cout << endl; // 换行
        }
        return;
    }

    // 选择当前数字 u，加入 path，递归处理下一个
    path.push_back(u);
    dfs(u + 1);
    path.pop_back(); // 回溯：撤销选择

    // 不选择当前数字 u，递归处理下一个
    dfs(u + 1);
}

int main() {
    cin >> n;  // 读入整数 n
    dfs(1);    // 从数字 1 开始递归
    return 0;
}
```

---

### 🧪 示例演示

输入：

```
3
```

输出（顺序任意）：

```
         ← 空集
3
2
2 3
1
1 3
1 2
1 2 3
```

---

### ✅ 总结

| 点      | 内容                     |
| ------ | ---------------------- |
| 解法类型   | 回溯 / 深度优先搜索（DFS）       |
| 每个数字处理 | 两种选择：选 or 不选           |
| 时间复杂度  | O(2ⁿ)，因为每个数字选或不选       |
| 空集处理   | 特判 `path.empty()` 输出空行 |

---

虽然**递归回溯（DFS）**是解决子集问题最直观、可扩展的方式，但在这类**求所有子集**的问题中，还有一种更快、更简洁的做法——**按二进制位枚举所有子集**，特别适合 n 较小的情况（本题 `n ≤ 15`）。

---

## ✅ 方法二：**位运算枚举所有子集（非递归）**

### 🌟 思想：

* 总共有 `n` 个数，所以子集总数是 `2^n` 种；
* 每种子集可以用一个 `n` 位二进制数来表示，第 `i` 位为 `1` 就表示选了第 `i` 个数。

### 🌰 举例（n = 3）：

| 二进制 | 子集    |
| --- | ----- |
| 000 | 空集    |
| 001 | 3     |
| 010 | 2     |
| 011 | 2 3   |
| 100 | 1     |
| 101 | 1 3   |
| 110 | 1 2   |
| 111 | 1 2 3 |

---

## ✅ C++ 实现（详细注释）

```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n; // 读入 n

    int total = 1 << n; // 共有 2^n 种子集

    for (int mask = 0; mask < total; ++mask) {
        bool first = true; // 控制空格输出

        for (int i = 0; i < n; ++i) {
            // 判断当前 mask 的第 i 位是否为1（是否选择第 i+1 个数）
            if (mask & (1 << i)) {
                if (!first) cout << " ";
                cout << i + 1;
                first = false;
            }
        }

        cout << endl; // 输出一行（空集时也输出空行）
    }

    return 0;
}
```

---

## ✅ 与递归方式对比

| 对比项   | 回溯（DFS）法  | 位运算法       |
| ----- | --------- | ---------- |
| 写法复杂度 | 中等（递归）    | 简洁（无递归）    |
| 执行效率  | 高         | 更高（少函数开销）  |
| 空集处理  | 需判断       | 自然包含       |
| 可扩展性  | 高（带约束更方便） | 低（仅生成所有子集） |

---

## ✅ 建议选用策略

* 如果只是**枚举所有子集（本题）**：推荐使用**位运算法**；
* 如果需要**在生成过程中剪枝 / 计数 / 约束条件**：推荐使用**回溯法**。

---
