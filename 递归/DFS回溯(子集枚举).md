### 🧠 问题简述

给定一个正整数 `n (1 ≤ n ≤ 15)`，你要从 `1 ~ n` 这 `n` 个整数中**任选若干个**（可以一个都不选），**输出所有可能的选择方案**。

* 每种方案是一个子集，子集内数字**升序排列**；
* 每行输出一个方案，不同方案行顺序**不要求固定**；
* 如果是“空集”，输出空行即可。

---

## ✅ 解题思路：回溯（DFS 构造所有子集）

我们可以用 **深度优先搜索**（递归）去枚举所有选择方案。

* 对于每一个数字 `i`，我们有两种选择：

  * **选它**
  * **不选它**
* 最后输出所有路径即可。

---

## ✅ C++ 实现（每行详细中文注释）

```cpp
#include <iostream>
#include <vector>
using namespace std;

int n;                      // 输入的上限值 n
vector<int> path;           // 当前构造的子集路径（选择了哪些数字）

// 递归函数，当前考虑从数字 u 开始选
void dfs(int u) {
    if (u > n) {
        // 已经遍历完所有数字，输出当前方案
        if (path.empty()) {
            cout << endl;  // 空集输出空行
        } else {
            for (int i = 0; i < path.size(); ++i) {
                if (i > 0) cout << " ";  // 数字之间加空格
                cout << path[i];         // 输出当前数字
            }
            cout << endl; // 换行
        }
        return;
    }

    // 选择当前数字 u，加入 path，递归处理下一个
    path.push_back(u);
    dfs(u + 1);
    path.pop_back(); // 回溯：撤销选择

    // 不选择当前数字 u，递归处理下一个
    dfs(u + 1);
}

int main() {
    cin >> n;  // 读入整数 n
    dfs(1);    // 从数字 1 开始递归
    return 0;
}
```

---

### 🧪 示例演示

输入：

```
3
```

输出（顺序任意）：

```
         ← 空集
3
2
2 3
1
1 3
1 2
1 2 3
```

---

### ✅ 总结

| 点      | 内容                     |
| ------ | ---------------------- |
| 解法类型   | 回溯 / 深度优先搜索（DFS）       |
| 每个数字处理 | 两种选择：选 or 不选           |
| 时间复杂度  | O(2ⁿ)，因为每个数字选或不选       |
| 空集处理   | 特判 `path.empty()` 输出空行 |

---

虽然**递归回溯（DFS）**是解决子集问题最直观、可扩展的方式，但在这类**求所有子集**的问题中，还有一种更快、更简洁的做法——**按二进制位枚举所有子集**，特别适合 n 较小的情况（本题 `n ≤ 15`）。

---

## ✅ 方法二：**位运算枚举所有子集（非递归）**

### 🌟 思想：

* 总共有 `n` 个数，所以子集总数是 `2^n` 种；
* 每种子集可以用一个 `n` 位二进制数来表示，第 `i` 位为 `1` 就表示选了第 `i` 个数。

### 🌰 举例（n = 3）：

| 二进制 | 子集    |
| --- | ----- |
| 000 | 空集    |
| 001 | 3     |
| 010 | 2     |
| 011 | 2 3   |
| 100 | 1     |
| 101 | 1 3   |
| 110 | 1 2   |
| 111 | 1 2 3 |

---

## ✅ C++ 实现（详细注释）

```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n; // 读入 n

    int total = 1 << n; // 共有 2^n 种子集

    for (int mask = 0; mask < total; ++mask) {
        bool first = true; // 控制空格输出

        for (int i = 0; i < n; ++i) {
            // 判断当前 mask 的第 i 位是否为1（是否选择第 i+1 个数）
            if (mask & (1 << i)) {
                if (!first) cout << " ";
                cout << i + 1;
                first = false;
            }
        }

        cout << endl; // 输出一行（空集时也输出空行）
    }

    return 0;
}
```

---

## ✅ 与递归方式对比

| 对比项   | 回溯（DFS）法  | 位运算法       |
| ----- | --------- | ---------- |
| 写法复杂度 | 中等（递归）    | 简洁（无递归）    |
| 执行效率  | 高         | 更高（少函数开销）  |
| 空集处理  | 需判断       | 自然包含       |
| 可扩展性  | 高（带约束更方便） | 低（仅生成所有子集） |

---

## ✅ 建议选用策略

* 如果只是**枚举所有子集（本题）**：推荐使用**位运算法**；
* 如果需要**在生成过程中剪枝 / 计数 / 约束条件**：推荐使用**回溯法**。

---

---

## ✅ 第一种方法：**递归回溯法（DFS）**

我们先来理解这段代码的**运行流程**。

### 🌟 回顾代码框架（已简化方便理解）：

```cpp
void dfs(int u) {
    if (u > n) {
        输出当前 path；
        return;
    }

    path.push_back(u);  // 选这个数
    dfs(u + 1);         // 去选下一个数
    path.pop_back();    // 撤销这个数

    dfs(u + 1);         // 不选这个数
}
```

---

### 🌰 示例：当 `n = 3` 时，整个 DFS 过程长什么样？

我们有 3 个数：\[1, 2, 3]

从 `u = 1` 开始，我们有两个选择：

* 选 1，进入下一层；
* 不选 1，进入下一层；

构成的“递归树”长这样：

```
                   [ ]
                /       \
              1          [ ]
            /   \       /   \
         1 2    1       2     [ ]
        /  \   / \     / \     / \
  [1 2 3][1 2][1 3][1] [2 3][2][3][ ]
```

### ✅ 输出顺序（每次走到最底层就输出 path）：

* \[1 2 3]
* \[1 2]
* \[1 3]
* \[1]
* \[2 3]
* \[2]
* \[3]
* \[]

每一次输出的 `path` 就是当前构造好的一个子集！

---

### 🧠 总结递归法逻辑

1. 对每个数字（从 1 到 n），尝试“选”或“不选”；
2. 用 `path` 记录当前已经选了哪些；
3. 每到最后（`u > n`），就输出当前 `path`；
4. 回溯时用 `path.pop_back()` 撤销上一步的选择；
5. 最终走遍所有路径，输出所有子集。

---

## ✅ 第二种方法：**位运算枚举法（非递归）**

### 🌟 回顾这段代码简化结构：

```cpp
int total = 1 << n; // 2^n

for (int mask = 0; mask < total; ++mask) {
    for (int i = 0; i < n; ++i) {
        if (mask & (1 << i)) {
            输出 i + 1;
        }
    }
}
```

---

### 🌰 举例：n = 3 时，mask 从 0 到 7（即二进制 000 到 111）

| mask（二进制） | 选中哪些数 | 对应子集     |
| --------- | ----- | -------- |
| 000       | none  | \[]      |
| 001       | 1     | \[3]     |
| 010       | 1     | \[2]     |
| 011       | 2     | \[2 3]   |
| 100       | 1     | \[1]     |
| 101       | 2     | \[1 3]   |
| 110       | 2     | \[1 2]   |
| 111       | 3     | \[1 2 3] |

⚠️注意：

* `mask & (1 << i)`：检查 mask 的第 i 位是否是 1；
* 如果是 1，就说明当前子集选择了第 i+1 个数；
* 外层循环控制所有子集；
* 内层循环检查每位是否选中。

---

## ✅ 简单对比运行方式

| 比较项   | 递归法               | 位运算法             |
| ----- | ----------------- | ---------------- |
| 思路    | 每次尝试选/不选下一个数      | 利用二进制控制所有选择组合    |
| 执行过程  | 构建“选择路径”再输出       | 直接按 0/1 位生成组合    |
| 输出顺序  | 深度优先（顺序不固定）       | 固定从空集到全集         |
| 空集处理  | path.empty() 输出空行 | mask = 0 时自动输出空行 |
| 最适合用途 | 带条件剪枝、结构递归类问题     | 枚举所有子集问题         |

---

## ✅ 最后总结一遍你可以记住：

> **递归法：走路径，模拟人类选择过程；**
>
> **位运算法：靠二进制位表示选或不选，效率高。**

---


---

### ✅ 问题目标

输入 `n = 3`，我们要输出 `1~3` 所有子集的组合，包括空集。

---

### ✅ 对应递归函数框架（含详细注释）：

```cpp
vector<int> path; // 当前选择的子集
int n;

void dfs(int u) {
    if (u > n) {
        // 递归到尽头，输出 path
        输出 path;
        return;
    }

    // 情况一：选择当前数字 u
    path.push_back(u);
    dfs(u + 1);
    path.pop_back(); // 撤销选择 u，回溯

    // 情况二：不选择当前数字 u
    dfs(u + 1);
}
```

---

## 🔍 完整展开：`n = 3` 的递归调用过程

我们从 `dfs(1)` 开始：

---

#### 第一步：从 1 开始

```
dfs(1)
  ├── 选择 1（path = [1]）
  │     ├── dfs(2)
  │     │     ├── 选择 2（path = [1,2]）
  │     │     │     ├── dfs(3)
  │     │     │     │     ├── 选择 3（path = [1,2,3]）→ 输出 1 2 3
  │     │     │     │     └── 不选 3（path = [1,2]）→ 输出 1 2
  │     │     └── 不选 2（path = [1]）
  │     │           ├── 选择 3（path = [1,3]）→ 输出 1 3
  │     │           └── 不选 3（path = [1]）→ 输出 1
  └── 不选 1（path = []）
        ├── 选择 2（path = [2]）
        │     ├── 选择 3（path = [2,3]）→ 输出 2 3
        │     └── 不选 3（path = [2]）→ 输出 2
        └── 不选 2（path = []）
              ├── 选择 3（path = [3]）→ 输出 3
              └── 不选 3（path = []）→ 输出空行（空集）
```

---

## ✅ 最终输出顺序如下（共 8 个子集）：

```
1 2 3
1 2
1 3
1
2 3
2
3
（空行）
```

---

### 🧠 每一条路径代表什么？

递归每到一个数字 `u`，都做两件事：

* **要它**：把 `u` 放进 `path`，进入下一层；
* **不要它**：不动 `path`，直接进入下一层；

每次走到 `u > n`，说明一个完整选择过程完成，立即输出 `path`。

---

### ✅ 总结记忆法

对于 n 个元素，一共有 2ⁿ 个组合。每次递归都“尝试要或不要”，DFS 会自动穷举出所有组合路径，适合输出所有子集的题。
