我们要解决的问题是：

> 从左上角走到右下角的路径总步数必须是 $2N - 1$，只能上下左右移动，在保证时间限制的同时，求路径上所经过方格费用之和最小值。

---

## 🧠 问题分析（简要概述）

这个问题本质上是一个**最短路径问题**，但路径长度固定为 $2N-1$，每步只能上下左右走一步，**每个格子都要花费费用**。

我们要在路径总步数等于 $2N-1$ 的条件下，求从 `(0,0)` 到 `(N-1,N-1)` 的最小代价。

这正好可以使用 **Dijkstra 算法** 来求从 `(0,0)` 到 `(N-1,N-1)` 的最小总代价路径（只要边权为非负，就适用 Dijkstra）。

---

## ✅ C++ 实现（使用最小堆的 Dijkstra，逐行中文注释）

```cpp
#include <iostream>               // 输入输出
#include <queue>                 // 优先队列（最小堆）
#include <vector>                // 使用 vector 存储地图
#include <cstring>               // 用于初始化
using namespace std;             // 使用标准命名空间

const int N = 110;               // 地图最大边长为100，留出冗余
const int INF = 1e9;             // 表示无穷大

int cost[N][N];                  // 存储每个格子的费用
int dist[N][N];                  // dist[i][j] 表示从(0,0)到(i,j)的最小费用
bool visited[N][N];             // 标记是否已经确定最短费用

// 四个方向：上、下、左、右
int dx[] = {-1, 1, 0, 0};        
int dy[] = {0, 0, -1, 1};

int main() {
    int n;
    cin >> n;                    // 输入地图边长

    // 输入地图的费用信息
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            cin >> cost[i][j];

    // 初始化距离数组为无穷大
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            dist[i][j] = INF;

    // 起点费用就是 cost[0][0]
    dist[0][0] = cost[0][0];

    // 最小堆：存储 pair<费用, 坐标>
    priority_queue<pair<int, pair<int, int>>, 
                   vector<pair<int, pair<int, int>>>, 
                   greater<>> pq;

    pq.push({dist[0][0], {0, 0}});  // 将起点加入堆中

    while (!pq.empty()) {
        auto [d, pos] = pq.top(); pq.pop();
        int x = pos.first, y = pos.second;

        if (visited[x][y]) continue;  // 如果该点已经处理过，就跳过
        visited[x][y] = true;         // 标记为已访问

        // 遍历四个方向
        for (int i = 0; i < 4; ++i) {
            int a = x + dx[i];
            int b = y + dy[i];
            // 判断新位置是否在地图内
            if (a >= 0 && a < n && b >= 0 && b < n) {
                // 如果从当前点走过去更便宜，则更新
                if (dist[a][b] > dist[x][y] + cost[a][b]) {
                    dist[a][b] = dist[x][y] + cost[a][b];
                    pq.push({dist[a][b], {a, b}}); // 入堆
                }
            }
        }
    }

    // 输出终点最小费用
    cout << dist[n - 1][n - 1] << endl;
    return 0;
}
```

---

## 🔁 示例说明

输入：

```
5
1  4  6  8  10
2  5  7  15 17
6  8  9  18 20
10 11 12 19 21
20 23 25 29 33
```

最优路径：

```
1 + 2 + 5 + 7 + 9 + 12 + 19 + 21 + 33 = 109
```

输出：

```
109
```

---

## ✅ 小结

| 项目     | 内容                              |
| ------ | ------------------------------- |
| 算法核心   | Dijkstra 最短路径                   |
| 路径限制   | 每步只能上下左右                        |
| 最终目标   | 从 `(0,0)` 到 `(n-1,n-1)` 的最小费用路径 |
| 时间复杂度  | $O(n^2 \log n)$ 适用于 n ≤ 100     |
| 是否保证时间 | 是，总步数 = $2n - 1$                |

---
这个问题本质上是**图的最短路径问题**，我们刚才使用的是：

---

## ✅ 使用的算法：**Dijkstra 算法**

### 📌 特点：

* 适用于**带权图**，**边权为非负数**
* 可以找出**从起点到终点的最小代价路径**
* 是一种**贪心 + 堆优化**的最短路算法

在这题中：

* 每个格子看作图中的一个点；
* 每次向上下左右移动，看作从一个点到相邻点的“有向边”，边权为目标格子的代价；
* 因此是典型的 Dijkstra 模型。

---

## ✅ 这是不是动态规划？

**是也不是，具体如下：**

| 角度     | 答案       | 理由                                                        |
| ------ | -------- | --------------------------------------------------------- |
| 从结构上看  | ✅ 类似 DP  | 每个状态（如走到格子(i,j)）依赖于之前状态（如(i−1,j),(i,j−1)...）              |
| 从实现方式看 | ❌ 不是DP   | 我们没有显式维护转移数组 f\[i]\[j]，而是用堆（priority\_queue）+ dist 数组逐步推进 |
| 从本质看   | ❌ 不是传统DP | 没有固定的方向性，方向是动态的、根据堆中最小值拓展的                                |

---

## ✅ 有没有更好的算法？

| 方法           | 适用条件         | 时间复杂度       | 是否更好                |
| ------------ | ------------ | ----------- | ------------------- |
| 动态规划（DP）     | 只能右/下，不能上下左右 | O(n²)       | ✅ 更快（在受限方向时）        |
| Dijkstra（本题） | 任意方向、代价非负    | O(n² log n) | ✅ 更通用               |
| A\* 启发式搜索    | 已知终点、且估价函数优秀 | O(logN)\~   | ❌ 理论快，但实现更复杂，适合寻路问题 |
| BFS（等权图）     | 所有边权 = 1     | O(n²)       | ❌ 不适用，本题边权非等值       |

---

## ✅ 什么时候可以用动态规划代替 Dijkstra？

如果路径**只能向下或向右**，那么就能用二维 DP 表求：

```cpp
f[i][j] = min(f[i-1][j], f[i][j-1]) + cost[i][j];
```

但本题允许**上下左右任意方向**，因此**不能用普通 DP**，必须用 **Dijkstra** 或 BFS（不适用，因为权值非等）。

---

## ✅ 小结对比：

| 方法       | 适用条件     | 优势       | 劣势        |
| -------- | -------- | -------- | --------- |
| 动态规划     | 方向固定     | 实现简单、快速  | 不支持回头、不灵活 |
| Dijkstra | 任意方向、正权值 | 灵活、通用    | 稍慢，代码略长   |
| A\*      | 有估价函数    | 更智能（如寻路） | 难以调试      |

---
我们现在来讨论这个问题用 **DFS + 剪枝（回溯 + 剪枝）** 的做法。

---

## 🧠 一、问题回顾

从左上角 `(0,0)` 走到右下角 `(n-1,n-1)`，每次只能走上下左右，且每一步花费目标格子的费用，**要求走“恰好 2n - 1” 步的路径中，费用最小。**

---

## ✅ 二、DFS + 剪枝方法思路（非常适合教学或练习）

### 1. 搜索模型：

* 从 `(0,0)` 开始，每步向上下左右走；
* 每次记录当前步数 `step` 和当前花费 `cost`；
* 走到 `(n-1,n-1)` 且步数为 `2n-1` 时，尝试更新最小值；
* 否则递归四个方向，继续搜索。

### 2. 剪枝思想：

在 DFS 过程中，如果当前的“路径”已经不可能成为最优解，可以**提前中止（剪枝）**。

#### ✅ 常见剪枝策略：

| 剪枝条件            | 含义                |
| --------------- | ----------------- |
| 步数超出 2n-1       | 说明路径太长，剪枝         |
| 当前位置越界          | 无效状态，剪枝           |
| 当前路径代价 ≥ 当前最小答案 | 已经不优了，没必要继续搜，剪枝   |
| 已经访问过的点（可选）     | 可加 visited 表，防止走圈 |

---

## ✅ 三、C++ 实现（含剪枝 + 全部中文注释）

```cpp
#include <iostream>         // 输入输出
#include <vector>           // 用于二维数组
#include <algorithm>        // 用于 min 函数
using namespace std;

const int N = 110;
int n;
int grid[N][N];             // 存储地图费用
int minCost = 1e9;          // 当前最小总费用，初始为极大值

bool visited[N][N];         // 标记是否访问过（可选）

// 四个方向：上、下、左、右
int dx[] = {-1, 1, 0, 0};
int dy[] = {0, 0, -1, 1};

// DFS 函数：当前位置(x,y)，已走步数step，总费用cost
void dfs(int x, int y, int step, int cost) {
    // 超出步数上限剪枝
    if (step > 2 * n - 1) return;

    // 如果到终点，并且恰好走了 2n - 1 步，尝试更新答案
    if (x == n - 1 && y == n - 1) {
        if (step == 2 * n - 1)
            minCost = min(minCost, cost);
        return;
    }

    // 当前路径已不优，剪枝
    if (cost >= minCost) return;

    // 标记当前位置为访问过
    visited[x][y] = true;

    // 向四个方向走
    for (int i = 0; i < 4; ++i) {
        int a = x + dx[i];
        int b = y + dy[i];

        // 边界检查，且不能走重复点（防止回头）
        if (a >= 0 && a < n && b >= 0 && b < n && !visited[a][b]) {
            dfs(a, b, step + 1, cost + grid[a][b]);
        }
    }

    // 恢复现场（回溯）
    visited[x][y] = false;
}

int main() {
    cin >> n;

    // 读入地图
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            cin >> grid[i][j];

    // 从 (0,0) 开始搜索
    dfs(0, 0, 1, grid[0][0]);

    cout << minCost << endl;
    return 0;
}
```

---

## ✅ 四、DFS + 剪枝方法总结

| 优点              | 缺点                    |
| --------------- | --------------------- |
| 思路清晰、易写、递归好理解   | 效率较低，对 100×100 地图可能超时 |
| 可加入路径打印（回溯恢复路径） | 剪枝不够严密时搜索空间巨大         |

---

## ✅ 适用场景

* 地图规模较小，如 n ≤ 15；
* 想要练习剪枝、DFS建模；
* 需要回溯出完整路径；

---
