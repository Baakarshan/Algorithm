问题 **大整数加法**：给定两个位数可能非常大的正整数（最长可达 100000 位），需要输出它们的**和**。

由于它们太大，**不能使用普通整数变量（如 int 或 long long）存储**，我们需要模拟加法的过程，像小学竖式加法一样，从**低位向高位逐位相加并进位**。

---

## ✅ C++ 解法（详细注释，适合比赛或刷题场景）

```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// 大整数加法函数：输入两个字符串，返回它们的和（字符串形式）
string add(string a, string b) {
    vector<int> A, B;  // 存储逆序的数字
    // 将字符串 a 转成整数并倒序存入 A
    for (int i = a.size() - 1; i >= 0; --i) A.push_back(a[i] - '0');
    for (int i = b.size() - 1; i >= 0; --i) B.push_back(b[i] - '0');

    vector<int> C;  // 存储结果（逆序）
    int carry = 0;  // 进位
    for (size_t i = 0; i < A.size() || i < B.size(); ++i) {
        int x = i < A.size() ? A[i] : 0;  // 第 a 个数的第 i 位
        int y = i < B.size() ? B[i] : 0;  // 第 b 个数的第 i 位
        int sum = x + y + carry;         // 当前位和进位相加
        C.push_back(sum % 10);           // 当前位的结果
        carry = sum / 10;                // 更新进位
    }
    if (carry) C.push_back(carry);       // 末尾还有进位

    // 构造结果字符串
    string res;
    for (int i = C.size() - 1; i >= 0; --i) res += C[i] + '0';
    return res;
}

int main() {
    string a, b;
    cin >> a >> b;                 // 输入两个超长整数
    cout << add(a, b) << endl;     // 输出结果
    return 0;
}
```

---

## 🧠 举例说明

输入：

```
99999999999999999999
1
```

过程：

```
从个位开始相加：
9+1=10 → 进位1，当前位0
9+0+1=10 → 进位1，当前位0
……
最后进位1补在最前面

结果：100000000000000000000
```

---

这是一个 **模拟高精度加法（大整数加法）** 的算法。

---

### ✅ 一、为什么要用这种算法？

* 普通整型变量（如 `int`、`long long`）最多只能表示 10^9 \~ 10^18 的整数；
* 本题输入的整数长度可以达到 **100000 位**，远远超过任何内置整型的范围；
* 所以我们不能直接用数值加法，必须像 **小学竖式加法** 一样，**手动逐位模拟加法**。

---

### ✅ 二、程序运行的整体思路

假设输入两个字符串表示的大整数：

```
a = "12345678901234567890"
b = "987654321"
```

#### 1. 将字符串反转并转为数字数组（低位在前）：

```cpp
a 变为 A = [0, 9, 8, ..., 1]（从个位到最高位）
b 变为 B = [1, 2, 3, ..., 9]
```

#### 2. 从最低位开始逐位相加，模拟人工竖式加法：

* 当前位置的计算：

  ```
  sum = A[i] + B[i] + carry
  当前结果位 = sum % 10
  新的进位 = sum / 10
  ```

* 一直加到最长的数字结束；

* 如果最终还有进位，再加一位。

---

### ✅ 三、以输入 `999` 和 `1` 为例

```text
  9 9 9
+     1
-------
1 0 0 0
```

程序步骤如下：

| 位数位置 | A\[i] | B\[i] | carry | sum | 新carry | C（结果）         |
| ---- | ----- | ----- | ----- | --- | ------ | ------------- |
| i=0  | 9     | 1     | 0     | 10  | 1      | \[0]          |
| i=1  | 9     | 0     | 1     | 10  | 1      | \[0, 0]       |
| i=2  | 9     | 0     | 1     | 10  | 1      | \[0, 0, 0]    |
| 最后   | -     | -     | 1     | 1   | 0      | \[0, 0, 0, 1] |

最终反转输出为 `1000`。

---

### ✅ 四、总结算法优点

* 可以处理任意位数的整数；
* 基于字符串和数组，**不依赖于大数库**；
* 时间复杂度是 O(n)，其中 n 是两个数中较长的位数；
* 空间复杂度 O(n)。

---
