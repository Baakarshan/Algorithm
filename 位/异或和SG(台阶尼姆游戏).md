我们要解决的问题是一个变种的 **Nim 游戏**：

> 玩家可以从任意台阶上拿走至少一个石子，将其放到**下一层**。最终无法移动者失败，问先手是否必胜。

---

## 🧠 一、问题简要概述

* 有 $n$ 级台阶，每级台阶 $i$ 上有 $a_i$ 个石子；
* 玩家轮流：**从任意一级拿1颗及以上石子，移到下一层**；
* 最后一层（地面）不能再操作，最终无法动者输；
* 双方都最优，问先手是否必赢。

---

## ✅ 二、模型转换 & 思路分析

这类博弈问题的通用解法为：

### 🎯 利用 **Sprague-Grundy 定理**：

> 每个子游戏可看作一个独立 Nim 游戏，整体游戏的 SG 值是各子游戏 SG 值的异或。

---

### ✅ 本题中的 SG 值规律：

#### 观察：

* 对于台阶 `i` 上的每个石子，它可以移动到 `i+1, i+2, ..., n`；
* 所以它的状态行为等价于一个 **起始 SG 值为 `i` 的 Nim 堆**；
* 同一台阶若有多个石子，按照 Nim 游戏规则，“偶数个相同 SG 值的堆”会**相互抵消**。

---

### ✅ 结论：

> 对于台阶 $i$，若 $a_i$ 是奇数，则 SG 值贡献为 $i$；
> 否则为 0。最后将所有这些 $i$ 异或起来，得到 Nim 和。

* 若结果 ≠ 0 ⇒ 先手必赢；
* 否则 ⇒ 后手必赢。

---

## ✅ 三、C++ 实现（高效，满足格式要求）

```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;

    int x, res = 0;             // res 表示异或和（Nim和）

    for (int i = 1; i <= n; ++i) {
        cin >> x;
        if (x % 2 == 1) {       // 只处理奇数个石子的台阶
            res ^= i;           // 台阶编号为 SG 值，异或统计
        }
    }

    cout << (res != 0 ? "Yes" : "No") << endl;
    return 0;
}
```

---

## 🧪 输入样例讲解

输入：

```
3
2 1 3
```

* 台阶 1 有偶数石子 → 无贡献
* 台阶 2 有奇数 → SG = 2
* 台阶 3 有奇数 → SG = 3

异或和：

```
2 ^ 3 = 1 ≠ 0 → 先手必赢
```

输出：

```
Yes
```

---

## ✅ 小结

| 项目       | 内容                 |
| -------- | ------------------ |
| 算法核心     | SG函数（每颗石子的SG为台阶编号） |
| Nim和判赢准则 | 异或和 ≠ 0：先手赢；=0：后手赢 |
| 时间复杂度    | O(n)               |
| 空间复杂度    | O(1)               |

---
