我们要解决的是经典博弈论中的：

> **Nim 游戏（尼姆游戏）**：两人轮流从任意一堆石子中取至少一个，最后无法操作者输。判断先手是否必胜。

---

## 🧠 一、问题简要概述

* 有 $n$ 堆石子，每堆有 $a_i$ 个；
* 两人轮流操作，每次从任意一堆中取至少一个石子；
* 谁无法操作（所有堆为空）就输了；
* 问先手在双方都采用最优策略下，是否能必赢。

---

## ✅ 二、核心结论（博弈论公式）

尼姆游戏的核心是 **异或和（XOR）**：

### 🎯 结论：

> 如果所有石子堆的数量进行异或（XOR）后的结果为 **0**，先手必败；
> 如果异或和不为 0，先手必赢！

### ✅ 数学表达：

```cpp
a[1] ^ a[2] ^ ... ^ a[n] == 0 → 后手胜
a[1] ^ a[2] ^ ... ^ a[n] ≠ 0 → 先手胜
```

这个异或和又被称作 Nim-Sum。

---

## ✅ 三、C++ 实现（简洁、明确）

```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;

    int x, xorSum = 0;
    for (int i = 0; i < n; ++i) {
        cin >> x;
        xorSum ^= x;  // 对所有石子堆进行异或
    }

    if (xorSum != 0) cout << "Yes" << endl;  // 先手必胜
    else cout << "No" << endl;               // 后手必胜

    return 0;
}
```

---

## 🔍 示例解析

输入：

```
2
2 3
```

计算：

```
2 ^ 3 = 1 ≠ 0 → 先手胜
```

输出：

```
Yes
```

---

## ✅ 四、小结

| 项目    | 内容              |
| ----- | --------------- |
| 算法类型  | 博弈论 + 位运算（异或）   |
| 核心结论  | 所有堆异或和为 0 → 后手胜 |
| 时间复杂度 | O(n)            |
| 空间复杂度 | O(1)            |

---
