
---

### ✅ 问题简述（你得理解规则）

* 有一个 5×6 的灯阵列，按钮和灯一一对应。
* 每按一个按钮，会翻转它本身和其上下左右灯的状态。
* 每盏灯初始状态是 0（熄灭）或 1（点亮）。
* 目标是找到**哪些按钮按下后，所有灯都变成熄灭（0）**。

---

### 🧠 关键观察

由于按同一个按钮两次相当于没按（因为奇偶抵消），**每个按钮最多只需要按 0 次或 1 次**（即按与不按两种选择）。

#### 所以，这个问题就是一个 5×6 的 **布尔选择问题**，按下 = 1，不按 = 0。

---

### 🧩 解法策略（最核心的算法）

#### 核心思想：**枚举第一行按钮的按法 + 推导下面行**

1. **第一行有 6 个按钮**，所以我们可以用一个6位的二进制数枚举出所有 64 种可能的按法。

2. 对于每一种按法，**推导出第二行到第五行的按法**：

   * 如果某一盏灯（比如 i 行 j 列）最终是亮的（=1），则说明它上面那行 j 列的按钮没处理好 → 需要下一行的按钮来补救（按一次让它再翻一次）。

3. 推到最后一行（第 5 行）后：

   * 只需检查最后一行是否全是 0。如果是 → 合法解法；否则 → 否定。

---

### 🔁 流程图理解

```
for 所有第一行的按法:
    推出第2行到第5行的按法:
        如果上一行第j列的灯是亮的：
            当前行的第j列按钮必须按
    检查最后一行是否成功熄灭
```

---

### ✅ C++ 解法

```cpp
#include <iostream>
#include <cstring>
using namespace std;

const int N = 6;

int ori[5][6];      // 原始灯状态
int g[5][6];        // 当前灯状态（用于模拟）
int press[5][6];    // 当前按钮方案

// 每按一下（x, y），影响它和周围的灯
int dx[] = {0, 0, 0, -1, 1};
int dy[] = {0, -1, 1, 0, 0};

void flip(int x, int y) {
    for (int k = 0; k < 5; ++k) {
        int nx = x + dx[k], ny = y + dy[k];
        if (nx >= 0 && nx < 5 && ny >= 0 && ny < 6)
            g[nx][ny] ^= 1; // 翻转灯状态
    }
}

int main() {
    int T;
    cin >> T;
    for (int t = 1; t <= T; ++t) {
        for (int i = 0; i < 5; ++i)
            for (int j = 0; j < 6; ++j)
                cin >> ori[i][j];

        bool found = false;

        for (int op = 0; op < (1 << 6); ++op) { // 枚举第一行的64种方案
            memcpy(g, ori, sizeof g);
            memset(press, 0, sizeof press);

            // 设置第一行按钮按法
            for (int j = 0; j < 6; ++j)
                if ((op >> j) & 1) {
                    press[0][j] = 1;
                    flip(0, j);
                }

            // 推导2~4行按钮按法
            for (int i = 1; i < 5; ++i)
                for (int j = 0; j < 6; ++j)
                    if (g[i - 1][j]) { // 上一行没灭，当前行j按钮必须按
                        press[i][j] = 1;
                        flip(i, j);
                    }

            // 检查最后一行是否全部熄灭
            bool ok = true;
            for (int j = 0; j < 6; ++j)
                if (g[4][j]) ok = false;

            if (ok) {
                found = true;
                cout << "PUZZLE #" << t << endl;
                for (int i = 0; i < 5; ++i) {
                    for (int j = 0; j < 6; ++j)
                        cout << press[i][j] << " ";
                    cout << endl;
                }
                break; // 找到一组解即可退出
            }
        }
    }
    return 0;
}
```

---

### 🧠 总结

* 只需要**枚举第一行的按钮方案**，再通过逻辑推出其他行的按法。
* 一共有 \$2^6 = 64\$ 种第一行组合，所以这个算法非常快。
* 使用位运算 `(op >> j) & 1` 枚举效率高。

---
好的，我们用**纯文字的方式详细讲解这道“熄灯问题”是如何解的**。以下是你需要理解的**完整过程和背后的逻辑**：

---

## 🧩 问题简化描述

有一个 **5行6列的灯阵（共30盏灯）**，每盏灯状态是亮（1）或灭（0）：

* 每按一个按钮，会翻转：

  * 自己位置的灯
  * 上、下、左、右的灯（如果存在）

我们的目标是：**通过按按钮，使所有灯都熄灭（变成0）**。

---

## 🧠 核心思路

### ✅ 关键结论：

1. **每个按钮最多只需要按一次**（因为按两次等于没按），所以每个按钮只有「按」或「不按」两个选择。
2. **按钮的顺序不影响最终结果**，因为翻灯操作是可交换的。
3. **你只需要枚举第一行按钮的按法**，剩下四行的按法可以根据“上一行”的状态**逐步推出**。

---

## 🔍 举个小例子（简化版理解）

假设有 3 行 6 列灯。

你发现**按第2行某个按钮，会影响第1行对应列的灯状态**。
于是你想到一个技巧：

* **如果第1行某个灯亮了（为1）**，那我们可以通过**按第2行对应位置按钮**来熄灭它（翻转一次）。

同理：

* 第2行亮灯 → 按第3行按钮
* 第3行亮灯 → 按第4行按钮
* ...
* 最后，**检查最后一行是否成功熄灭（全是0）**，就能判断当前方案是否成功。

---

## 🧮 步骤细化

1. **枚举第一行的按钮按法**：

   * 第一行有6个按钮，共有 2⁶ = 64 种按法。

2. **根据第1行按法，推导出第2\~5行的按法**：

   * 从上到下逐行判断：如果上一行第j列的灯还亮着（=1），那必须按当前行的第j个按钮来熄灭它。

3. **检查最后一行是否已经熄灭**：

   * 如果成功 → 当前整组按钮按法是一个合法解。
   * 如果失败 → 继续尝试下一种第一行按法。

---

## 📌 关键细节解释

### 🔄 为啥只枚举第一行？

因为只要第一行定下来，**从上到下的操作就被完全确定了**。每一行的按钮按不按，完全由上面一行是否还有灯亮决定。

### 🔄 为啥能这样“顺着推”？

因为每按一个按钮只会影响“自己”以及“上、下、左、右”的灯。
你要熄灭第 i 行的灯，最直接的方式是去按 i+1 行的按钮。

---

## ✅ 总结

> 这是一道经典的**状态推导问题**，虽然看起来是 5×6 的组合问题，但借助“**第一行枚举 + 状态推导**”技巧，我们只需要枚举 64 种可能，每种最多推导 5 行，算法复杂度是完全可接受的。

---
