### 🟢 问题简述

人生有三个生理周期：

* **体力周期**：23天
* **情感周期**：28天
* **智力周期**：33天

每种周期都有高峰日。由于它们的周期长度不同，因此三个高峰通常不会在同一天。

> 已知从每年的第 1 天开始，每个周期上一次出现高峰的时间 `p, e, i`，以及当前时间 `d`，请你计算从 **`d+1` 开始起**，**下一次三个高峰在同一天**出现是在**多少天后**。

---

### 🎯 目标：

求出满足下面这三个条件的最小正整数天数 `x`，并且要求 `x > d`：

$$
\begin{cases}
x \equiv p \pmod{23} \\
x \equiv e \pmod{28} \\
x \equiv i \pmod{33} \\
\end{cases}
$$

我们称这种问题为：**同余方程组求解**问题。它可以通过一种经典数学方法叫作 **中国剩余定理（CRT）** 来解决。

---

## ✴️ 什么是中国剩余定理（CRT）？

它的作用是解决一组模线性方程（同余）：

* 比如：x ≡ 2 (mod 3), x ≡ 3 (mod 5), x ≡ 2 (mod 7)

CRT 可以求出这个 `x` 的最小正整数解，并知道这个解每隔多少天会重复出现（这些模数的最小公倍数）。

---

## ✅ 题目实际对应 CRT 的模型

| 周期   | 变量                         | 说明              |
| ---- | -------------------------- | --------------- |
| 体力周期 | p                          | 上一次体力高峰出现在第 p 天 |
| 情感周期 | e                          | 上一次情感高峰出现在第 e 天 |
| 智力周期 | i                          | 上一次智力高峰出现在第 i 天 |
| 当前时间 | d                          | 今天是第 d 天        |
| 目标   | 求一个 x，满足 `x > d` 且三种高峰同时发生 |                 |

目标求解：

$$
x \equiv p \mod 23,\quad x \equiv e \mod 28,\quad x \equiv i \mod 33
$$

---

## 🧮 如何解这个方程组（CRT 解法）？

我们将用**构造法**求这个 `x`：

1. 首先算出周期总长度 `M = 23 * 28 * 33 = 21252`
   ⇒ 所有周期每 21252 天会重复一次
2. 然后分别构造出每个部分贡献：

设：

* $M_1 = \frac{M}{23} = 924$
* $M_2 = \frac{M}{28} = 759$
* $M_3 = \frac{M}{33} = 644$

每个 Mi 与其模数互质，我们通过计算逆元：

$$
x = (p × M_1 × \text{inv}(M_1, 23) + e × M_2 × \text{inv}(M_2, 28) + i × M_3 × \text{inv}(M_3, 33)) \mod 21252
$$

得到的 `x` 就是**第几天出现三个高峰**。

最后，用 `((x - d + 21252) % 21252)` 计算与当前时间 `d` 的差距。

---

## ✅ 完整 C++ 实现（加注释）

```cpp
#include <iostream>
using namespace std;

// 扩展欧几里得算法计算 a 在模 m 下的逆元
int inv(int a, int m) {
    int m0 = m, x0 = 0, x1 = 1;
    while (a > 1) {
        int q = a / m;
        int t = m;
        m = a % m; a = t;
        t = x0;
        x0 = x1 - q * x0; x1 = t;
    }
    if (x1 < 0) x1 += m0;
    return x1;
}

// 使用中国剩余定理计算 x
int crt(int p, int e, int i) {
    const int m1 = 23, m2 = 28, m3 = 33;
    const int M = m1 * m2 * m3; // 最小公共周期 21252
    int M1 = M / m1; // 924
    int M2 = M / m2; // 759
    int M3 = M / m3; // 644

    int x = 0;
    x += p * M1 * inv(M1, m1);
    x += e * M2 * inv(M2, m2);
    x += i * M3 * inv(M3, m3);

    x %= M;
    if (x == 0) x = M;
    return x;
}

int main() {
    int p, e, i, d;
    int case_num = 1;
    while (cin >> p >> e >> i >> d) {
        if (p == -1 && e == -1 && i == -1 && d == -1) break;

        int next_peak = crt(p, e, i); // 计算下一次三个高峰重合的绝对天数
        int result = (next_peak - d + 21252) % 21252;
        if (result == 0) result = 21252;

        cout << "Case " << case_num++ << ": the next triple peak occurs in " << result << " days." << endl;
    }
    return 0;
}
```

---

## 🧪 样例输入输出说明

输入：

```
0 0 0 0
```

意思是：三种高峰都在第 0 天出现，当前也是第 0 天。

输出：

```
Case 1: the next triple peak occurs in 21252 days.
```

表示下次再一起出现就是 21252 天后。

---

## ✅ 小结

| 项目   | 内容                    |
| ---- | --------------------- |
| 算法类型 | 中国剩余定理求解同余方程组         |
| 重复周期 | 所有高峰最多 21252 天会一起出现一次 |
| 核心计算 | CRT + 模逆元 + 模加法       |
| 应用场景 | 同余方程、调度周期、日期类问题建模     |

---

### 🟢 问题简述

我们要找出从第 `d+1` 天开始，**下一个体力、情感、智力周期同时高峰的日子**。每种周期分别是：

* 体力周期：每 23 天一个高峰
* 情感周期：每 28 天一个高峰
* 智力周期：每 33 天一个高峰

已知某一次高峰的时间 `p, e, i`，求最近一次 `x` 满足：

$$
\begin{cases}
x \equiv p \pmod{23} \\
x \equiv e \pmod{28} \\
x \equiv i \pmod{33} \\
x > d
\end{cases}
$$

---

## 🔍 爆搜（暴力枚举）思路详解

### 🧠 核心思想：

我们从 `d+1` 开始，每次加1天，判断该天是否满足：

```cpp
(x - p) % 23 == 0 &&
(x - e) % 28 == 0 &&
(x - i) % 33 == 0
```

只要这三个条件都满足了，就找到了最近的下一次三个高峰重合的时间。

---

## ✅ 暴力 C++ 实现（可对比 CRT 版本）

```cpp
#include <iostream>
using namespace std;

int main() {
    int p, e, i, d;
    int case_num = 1;
    while (cin >> p >> e >> i >> d) {
        if (p == -1 && e == -1 && i == -1 && d == -1) break;

        int x = d + 1;
        while (true) {
            if ((x - p) % 23 == 0 &&
                (x - e) % 28 == 0 &&
                (x - i) % 33 == 0) {
                cout << "Case " << case_num++ << ": the next triple peak occurs in " << (x - d) << " days." << endl;
                break;
            }
            ++x;
        }
    }
    return 0;
}
```

---

## 🧪 示例运行（等价于CRT）

输入：

```
0 0 0 0
```

输出：

```
Case 1: the next triple peak occurs in 21252 days.
```

---

## ⏱ 时间复杂度分析

* **最坏情况**：从 `d` 一直枚举到 21252
* 每次只做3次模运算，速度很快
* **适用于数据范围小的情况（本题限制在 21252 以内）**

---

## 🧠 总结对比：暴力 vs CRT

| 对比项  | 暴力枚举法         | 中国剩余定理法（CRT）      |
| ---- | ------------- | ----------------- |
| 核心思想 | 从 d+1 开始逐天试验  | 直接通过数学计算求最小解      |
| 时间效率 | 最坏 O(21252-d) | 固定时间 O(1)，仅计算3次逆元 |
| 编码难度 | 简单易懂          | 稍复杂（需要逆元+构造公式）    |
| 稳定性  | 非常稳（不用担心错解）   | 需要注意逆元是否实现正确      |

---

## 📘 建议

* **想练习数学算法就用 CRT**
* **要快速通过题目、代码短小清晰，用暴力枚举也没问题**

如果你需要我画个流程图展示暴力是怎么逐步验证的，或者希望对逆元实现再深入讲讲，我也可以继续补充～
