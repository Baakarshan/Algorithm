这是一个经典的**大数据量排序问题**，目标是将最多 10⁵ 个整数进行排序，要求时间尽可能快。

---

## ✅ 推荐方法：**归并排序 + 快速 IO**

* 时间复杂度：O(n log n)，稳定；
* 空间复杂度：O(n)，可控；
* **比快速排序更稳，不会爆栈，不会因“极端输入”退化到 O(n²)**。

---

### 🔧 C++ 代码如下（手写归并排序）：

```cpp
#include <iostream>             // 引入输入输出库
using namespace std;

const int N = 1e5 + 10;        // 定义最大数组长度（最多10万个数 + 安全边界）
int a[N], temp[N];             // a[] 为原始数据数组，temp[] 为辅助归并排序用的临时数组

// 快速输入输出，关闭同步，提升 cin/cout 的效率
void fastIO() {
    ios::sync_with_stdio(false);   // 关闭 C++ 的 IO 同步，提升效率
    cin.tie(nullptr);              // 解除 cin 和 cout 的绑定，加快 cin
}

// 归并排序核心函数，对数组 a 中下标从 l 到 r 的部分进行排序
void merge_sort(int a[], int l, int r) {
    if (l >= r) return;            // 如果区间只剩一个或没有元素，递归结束

    int mid = (l + r) / 2;         // 取中间位置，将区间一分为二
    merge_sort(a, l, mid);         // 递归排序左半部分 [l, mid]
    merge_sort(a, mid + 1, r);     // 递归排序右半部分 [mid+1, r]

    // 以下开始“合并”两个已经排好序的部分
    int i = l;          // 指针 i 遍历左半部分
    int j = mid + 1;    // 指针 j 遍历右半部分
    int k = 0;          // 指针 k 用于临时数组 temp[]

    // 合并两个有序子数组
    while (i <= mid && j <= r) {
        if (a[i] <= a[j])          // 如果左边小于等于右边的当前元素
            temp[k++] = a[i++];    // 把左边元素放入 temp，然后 i++
        else
            temp[k++] = a[j++];    // 否则放入右边元素，然后 j++
    }

    // 如果左半部分还有剩余元素，全部拷贝进 temp
    while (i <= mid) temp[k++] = a[i++];

    // 如果右半部分还有剩余元素，也全部拷贝进 temp
    while (j <= r) temp[k++] = a[j++];

    // 将 temp 中排好序的内容复制回 a[] 的原来位置上（覆盖原数据）
    for (int t = 0; t < k; ++t) {
        a[l + t] = temp[t];        // 注意要从 l 开始覆盖，l+t 是真实索引
    }
}

int main() {
    fastIO();                      // 启用快速输入输出

    int n;
    cin >> n;                      // 读取数据长度 n

    // 读取 n 个整数存入数组 a[]
    for (int i = 0; i < n; ++i) cin >> a[i];

    merge_sort(a, 0, n - 1);       // 调用归并排序函数，对整个数组排序

    // 输出排序后的数组
    for (int i = 0; i < n; ++i) {
        cout << a[i];              // 输出第 i 个元素
        if (i != n - 1) cout << " ";  // 每个数后输出空格，最后一个不加
    }
    cout << endl;                  // 换行，结束输出

    return 0;                      // 正常退出程序
}

```

---

### ✅ 输入样例

```
12
111584322 907287398 13562672 615771042 83035480 323016588 501254568 158361642 388135644 58329696 400904710 38908140
```

### ✅ 输出样例

```
13562672 38908140 58329696 83035480 111584322 158361642 323016588 388135644 400904710 501254568 615771042 907287398
```

---

### 🚀 优点总结

| 特点        | 归并排序表现     |
| --------- | ---------- |
| 最坏时间复杂度   | O(n log n) |
| 是否稳定      | 是          |
| 是否受输入影响   | 否          |
| 是否容易超时/爆栈 | 否          |
| 支持大数据     | ✔          |

---

下面以 `n = 6` 的输入样例来完整**展开归并排序的执行流程树**，帮助理解它是如何将数组一步一步拆解并合并排序的。

---

### ✅ 示例数组（输入）：

```
a = [8, 3, 5, 2, 6, 1]
```

---

### 🔍 归并排序递归 + 合并的完整流程树如下：

```
merge_sort(0, 5)
├── merge_sort(0, 2)
│   ├── merge_sort(0, 1)
│   │   ├── merge_sort(0, 0) → 单元素，返回
│   │   └── merge_sort(1, 1) → 单元素，返回
│   │   → merge(0,1): [8,3] → [3,8]
│   └── merge_sort(2, 2) → 单元素，返回
│   → merge(0,2): [3,8,5] → [3,5,8]
├── merge_sort(3, 5)
│   ├── merge_sort(3, 4)
│   │   ├── merge_sort(3, 3) → 单元素，返回
│   │   └── merge_sort(4, 4) → 单元素，返回
│   │   → merge(3,4): [2,6] → [2,6]
│   └── merge_sort(5, 5) → 单元素，返回
│   → merge(3,5): [2,6,1] → [1,2,6]
→ merge(0,5): [3,5,8,1,2,6] → [1,2,3,5,6,8]
```

---

### 🔁 每次 merge 的详细内容：

1. **merge(0,1)**：8 和 3 → 排序 → `[3, 8]`
2. **merge(0,2)**：3, 8, 5 → 排序 → `[3, 5, 8]`
3. **merge(3,4)**：2 和 6 → 排序 → `[2, 6]`
4. **merge(3,5)**：2, 6, 1 → 排序 → `[1, 2, 6]`
5. **merge(0,5)**：合并 `[3, 5, 8]` 和 `[1, 2, 6]` → 最终结果 `[1, 2, 3, 5, 6, 8]`

---

### 🧠 思维图解（文字描述）

我们可以把排序过程理解为：

* **拆分阶段**：把数组一直对半切分成最小的单元素；
* **合并阶段**：从底向上开始把左右两部分排序后合并；
* 每次 merge 都是比较两个有序数组（像拉链合并一样）；
* 最后一次 merge 会合并整个数组。

---

### 🧩 归并排序 vs 快速排序

| 属性      | 归并排序       | 快速排序（手写）            |
| ------- | ---------- | ------------------- |
| 时间复杂度   | O(n log n) | O(n log n) 最坏 O(n²) |
| 是否稳定    | ✅ 是        | ❌ 否                 |
| 是否受输入影响 | ❌ 否        | ✅ 是（极端输入）           |
| 空间开销    | O(n)       | O(1) 原地             |
| 大数据推荐   | ✅ 是（更稳）    | ❌ 小心爆栈              |

---

