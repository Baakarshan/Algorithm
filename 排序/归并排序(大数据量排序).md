这是一个经典的**大数据量排序问题**，目标是将最多 10⁵ 个整数进行排序，要求时间尽可能快。

---

## ✅ 推荐方法：**归并排序 + 快速 IO**

* 时间复杂度：O(n log n)，稳定；
* 空间复杂度：O(n)，可控；
* **比快速排序更稳，不会爆栈，不会因“极端输入”退化到 O(n²)**。

---

### 🔧 C++ 代码如下（手写归并排序）：

```cpp
#include <iostream>
using namespace std;

const int N = 1e5 + 10;
int a[N], temp[N];  // 原数组 & 辅助数组

// 快速 IO
void fastIO() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
}

// 归并排序函数：递归将 [l,r] 区间排序
void merge_sort(int a[], int l, int r) {
    if (l >= r) return;

    int mid = (l + r) / 2;
    merge_sort(a, l, mid);        // 递归排序左半部分
    merge_sort(a, mid + 1, r);    // 递归排序右半部分

    // 合并两个有序数组
    int i = l, j = mid + 1, k = 0;
    while (i <= mid && j <= r) {
        if (a[i] <= a[j]) temp[k++] = a[i++];
        else temp[k++] = a[j++];
    }
    while (i <= mid) temp[k++] = a[i++];  // 复制剩余左边
    while (j <= r) temp[k++] = a[j++];    // 复制剩余右边

    // 拷贝回原数组
    for (int t = 0; t < k; ++t) {
        a[l + t] = temp[t];
    }
}

int main() {
    fastIO();  // 打开快速输入输出

    int n;
    cin >> n;
    for (int i = 0; i < n; ++i) cin >> a[i];

    merge_sort(a, 0, n - 1);  // 对数组排序

    for (int i = 0; i < n; ++i) {
        cout << a[i];
        if (i != n - 1) cout << " ";
    }
    cout << endl;

    return 0;
}
```

---

### ✅ 输入样例

```
12
111584322 907287398 13562672 615771042 83035480 323016588 501254568 158361642 388135644 58329696 400904710 38908140
```

### ✅ 输出样例

```
13562672 38908140 58329696 83035480 111584322 158361642 323016588 388135644 400904710 501254568 615771042 907287398
```

---

### 🚀 优点总结

| 特点        | 归并排序表现     |
| --------- | ---------- |
| 最坏时间复杂度   | O(n log n) |
| 是否稳定      | 是          |
| 是否受输入影响   | 否          |
| 是否容易超时/爆栈 | 否          |
| 支持大数据     | ✔          |

---

下面以 `n = 6` 的输入样例来完整**展开归并排序的执行流程树**，帮助理解它是如何将数组一步一步拆解并合并排序的。

---

### ✅ 示例数组（输入）：

```
a = [8, 3, 5, 2, 6, 1]
```

---

### 🔍 归并排序递归 + 合并的完整流程树如下：

```
merge_sort(0, 5)
├── merge_sort(0, 2)
│   ├── merge_sort(0, 1)
│   │   ├── merge_sort(0, 0) → 单元素，返回
│   │   └── merge_sort(1, 1) → 单元素，返回
│   │   → merge(0,1): [8,3] → [3,8]
│   └── merge_sort(2, 2) → 单元素，返回
│   → merge(0,2): [3,8,5] → [3,5,8]
├── merge_sort(3, 5)
│   ├── merge_sort(3, 4)
│   │   ├── merge_sort(3, 3) → 单元素，返回
│   │   └── merge_sort(4, 4) → 单元素，返回
│   │   → merge(3,4): [2,6] → [2,6]
│   └── merge_sort(5, 5) → 单元素，返回
│   → merge(3,5): [2,6,1] → [1,2,6]
→ merge(0,5): [3,5,8,1,2,6] → [1,2,3,5,6,8]
```

---

### 🔁 每次 merge 的详细内容：

1. **merge(0,1)**：8 和 3 → 排序 → `[3, 8]`
2. **merge(0,2)**：3, 8, 5 → 排序 → `[3, 5, 8]`
3. **merge(3,4)**：2 和 6 → 排序 → `[2, 6]`
4. **merge(3,5)**：2, 6, 1 → 排序 → `[1, 2, 6]`
5. **merge(0,5)**：合并 `[3, 5, 8]` 和 `[1, 2, 6]` → 最终结果 `[1, 2, 3, 5, 6, 8]`

---

### 🧠 思维图解（文字描述）

我们可以把排序过程理解为：

* **拆分阶段**：把数组一直对半切分成最小的单元素；
* **合并阶段**：从底向上开始把左右两部分排序后合并；
* 每次 merge 都是比较两个有序数组（像拉链合并一样）；
* 最后一次 merge 会合并整个数组。

---

### 🧩 归并排序 vs 快速排序

| 属性      | 归并排序       | 快速排序（手写）            |
| ------- | ---------- | ------------------- |
| 时间复杂度   | O(n log n) | O(n log n) 最坏 O(n²) |
| 是否稳定    | ✅ 是        | ❌ 否                 |
| 是否受输入影响 | ❌ 否        | ✅ 是（极端输入）           |
| 空间开销    | O(n)       | O(1) 原地             |
| 大数据推荐   | ✅ 是（更稳）    | ❌ 小心爆栈              |

---

