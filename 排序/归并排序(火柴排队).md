# Inversion Count via Rank Mapping (Revised)

🧠 算法介绍
本算法旨在解决一个排列匹配问题，目标是最小化两列火柴高度差的平方和，并求出达到该状态所需的最少交换次数。

**核心思想**：
1.  **最小化距离**：为了最小化距离 `Σ(aᵢ - bᵢ)²`，必须将 `a` 和 `b` 序列中排名相同的火柴配对。即 `a` 中第 `k` 小的火柴应与 `b` 中第 `k` 小的火柴在最终排列中处于相同位置。

2.  **问题转化与排名化**：我们将问题转化为寻找一个排列的逆序对数量。
    *   **排名化**：首先，我们将原始的高度值替换为它们在各自数组内的排名。例如，若 `a = [2, 3, 1, 4]`，其排名化数组为 `a_ranked = [1, 2, 0, 3]`（1是第0小，2是第1小，以此类推）。对 `b` 数组也做同样处理。
    *   **建立映射**：我们固定 `a` 序列的排名作为基准。创建一个映射数组 `c`，其中 `c[k]` 存储的是 `a` 序列中排名为 `k` 的火柴的**原始位置**。
    *   **构建目标排列**：遍历 `b` 序列的每个原始位置 `i`，其排名为 `b_ranked[i]`。根据匹配原则，它需要与 `a` 序列中排名同样为 `b_ranked[i]` 的火柴对齐。而`a`中该排名火柴的原始位置是 `c[b_ranked[i]]`。因此，我们构建一个新的目标排列 `p`，令 `p[i] = c[b_ranked[i]]`。
    *   这个目标排列 `p` 的逆序对数量，即为将 `b` 序列调整到与 `a` 序列排名一致所需的最少交换次数，也就是最终答案。

3.  **求解逆序对**：使用高效的**归并排序**算法来计算目标排列 `p` 的逆序对数量，时间复杂度为 O(n log n)。

*   **时间复杂度**：O(n log n)，主要由排名化过程中的排序和计算逆序对的归并排序决定。
*   **空间复杂度**：O(n)，用于存储排名化数组、映射数组、目标排列以及归并排序所需的临时数组。

🔍 实现思路
1.  **数据结构设计**：
    *   `std::vector<int>` `a`, `b`: 存储原始火柴高度。
    *   `std::vector<int>` `p`: 临时数组，用于排名化和归并排序。
    *   `std::vector<int>` `c`: 映射数组。
2.  **算法流程**：
    *   **步骤一：排名化**
        *   定义一个辅助函数 `rankify`。该函数接受一个数组（如 `a`）作为输入。
        *   在函数内部，创建一个 `(原始值索引, 值)` 的 `pair` 数组，并根据值对其排序。
        *   根据排序结果，将原始数组 `a` 的元素替换为其排名。例如，`a[p[i]] = i`，其中 `p[i]` 是排序后第 `i` 个元素的原始索引。
        *   分别对 `a` 和 `b` 调用 `rankify` 函数。
    *   **步骤二：构建映射和目标排列**
        *   创建映射数组 `c`。遍历排名化后的 `a` 数组，`c[a[i]] = i`。这记录了 `a` 中每个排名 `k` (`a[i]`) 所在的原始位置 `i`。
        *   遍历排名化后的 `b` 数组，用 `c` 来构建最终的目标排列。`b[i] = c[b[i]]`。（为了节省空间，直接在 `b` 数组上操作）。
    *   **步骤三：计算逆序对**
        *   实现一个标准的基于归并排序的逆序对计算函数 `merge_sort_and_count`，该函数对 `b` 数组进行操作。
        *   确保在计算逆序对数量时，所有加法都对 `99,999,997` 取模。
    *   **步骤四：输出结果**
        *   调用 `merge_sort_and_count` 计算 `b` 数组（现为目标排列）的逆序对数，并输出结果。

💻 C++11 实现代码
```cpp
#include <iostream> // 引入输入输出流库
#include <vector>   // 引入动态数组 vector
#include <algorithm>// 引入算法库，主要是为了 sort
#include <utility>  // 引入 pair

// 定义模数
const int MOD = 99999997;

// 全局临时数组，用于归并排序，避免在递归中反复创建
std::vector<int> temp_arr;

// 辅助函数，将输入数组 arr 的值替换为其排名 (0-indexed)
void rankify(std::vector<int>& arr) {
    int n = arr.size(); // 获取数组大小
    std::vector<int> p(n); // 创建索引数组
    for (int i = 0; i < n; ++i) { // 初始化索引数组 p[i] = i
        p[i] = i;
    }

    // 使用 lambda 表达式根据 arr 的值对索引数组 p 进行排序
    std::sort(p.begin(), p.end(), [&](int i, int j) {
        return arr[i] < arr[j];
    });

    // 根据排序后的索引，将 arr 的值更新为其排名
    // arr[p[i]] 原本是第 i 小的元素，现在将其值设为 i
    for (int i = 0; i < n; ++i) {
        arr[p[i]] = i;
    }
}

// 归并排序并计算逆序对的函数
long long merge_sort_and_count(std::vector<int>& arr, int left, int right) {
    if (left >= right) return 0; // 递归终止条件

    int mid = left + (right - left) / 2; // 分割数组
    
    // 递归计算左右两半的逆序对数，并对结果取模
    long long inv_count = (merge_sort_and_count(arr, left, mid) + merge_sort_and_count(arr, mid + 1, right)) % MOD;

    // --- 合并阶段 ---
    int i = left, j = mid + 1, k = left;
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) { // 如果左边元素较小，不构成逆序对
            temp_arr[k++] = arr[i++];
        } else { // 如果左边元素大于右边，构成逆序对
            temp_arr[k++] = arr[j++];
            // arr[i] 及之后的所有左半部分元素都比 arr[j] 大
            inv_count = (inv_count + (mid - i + 1)) % MOD;
        }
    }

    // 复制剩余的元素
    while (i <= mid) temp_arr[k++] = arr[i++];
    while (j <= right) temp_arr[k++] = arr[j++];

    // 将排序好的临时数组复制回原数组
    for (i = left; i <= right; ++i) {
        arr[i] = temp_arr[i];
    }

    return inv_count;
}

// main 函数是程序的入口点
int main() {
    // 加速 C++ 的 I/O 操作
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n; // 声明火柴数目
    std::cin >> n; // 读取 n

    std::vector<int> a(n), b(n); // 创建存储火柴高度的 vector

    // 读取两列火柴的高度
    for (int i = 0; i < n; ++i) std::cin >> a[i];
    for (int i = 0; i < n; ++i) std::cin >> b[i];

    // 步骤一：将 a 和 b 数组的值都替换为它们各自的排名
    rankify(a);
    rankify(b);

    // 步骤二：建立映射并构建目标排列
    // c[k] = i 表示 a 数组中排名为 k 的元素，其原始位置是 i
    std::vector<int> c(n);
    for (int i = 0; i < n; ++i) {
        c[a[i]] = i;
    }

    // 遍历 b 数组，将其元素替换为目标位置
    // b[i] 原本是 b 数组在位置 i 的排名
    // c[b[i]] 是 a 数组中与 b[i] 排名相同的元素的原始位置
    // 新的 b[i] 构成了需要计算逆序对的目标排列
    for (int i = 0; i < n; ++i) {
        b[i] = c[b[i]];
    }

    // 为归并排序的临时数组分配空间
    temp_arr.resize(n);

    // 步骤三：计算目标排列（现在存储在 b 中）的逆序对数并输出
    std::cout << merge_sort_and_count(b, 0, n - 1) << std::endl;

    return 0; // 程序正常结束
}
```
