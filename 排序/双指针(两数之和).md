### 🧠 问题概述

给你一个**升序数组**，和一个目标和 `target`，需要在数组中找出**两个数**，使它们的和正好等于 `target`，然后输出它们的下标（下标从 0 开始，输出要满足 i < j）。

这是双指针的经典入门题之一，考察**有序数组中两数之和问题**。

---

## ✅ 解题思路（双指针 Two Pointers）

由于数组是**升序排列**，我们可以使用两个指针：

* 一个从左边（最小数）开始：`i = 0`
* 一个从右边（最大数）开始：`j = n - 1`

然后每次检查 `a[i] + a[j]`：

* 如果正好等于 `target`，就输出 `i j`，结束；
* 如果小于 `target`，说明需要更大 ⇒ 增大左指针 `i++`；
* 如果大于 `target`，说明需要更小 ⇒ 减小右指针 `j--`；

这种方式的效率是 **O(n)**，非常高效！

---

## ✅ C++ 实现代码（含注释解释）

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int target, n;
    cin >> target >> n;

    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];

    // 双指针初始化
    int i = 0, j = n - 1;

    while (i < j) {
        int sum = a[i] + a[j];

        if (sum == target) {
            cout << i << " " << j << endl;
            break;
        } else if (sum < target) {
            i++;  // 左边小了，要大点
        } else {
            j--;  // 右边大了，要小点
        }
    }

    return 0;
}
```

---

## 🧪 样例演示

输入：

```
17 7
1 3 5 7 10 11 19
```

双指针从两端往中间走，直到找到：

```
a[3] + a[4] = 7 + 10 = 17
```

输出：

```
3 4
```

---

## 📌 总结：双指针关键点

| 点位    | 说明                       |
| ----- | ------------------------ |
| 前提    | 数组已排序（升序）                |
| 指针初始化 | 左指针从头，右指针从尾              |
| 移动规则  | 当前和太小 → 左指针右移；太大 → 右指针左移 |
| 时间复杂度 | O(n)，比暴力法 O(n²) 快得多      |

---

