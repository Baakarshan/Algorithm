# 2D Difference Array (Unified)

🧠 算法介绍
该算法采用**统一二维差分**的思想，高效地解决对二维矩阵的子矩阵进行批量加减操作的问题。其核心是将矩阵的初始状态和所有的更新操作都转化为对同一个差分矩阵 `b` 的修改。

**核心思想**：
1.  **统一表示**：我们构建一个差分矩阵 `b`，它唯一地表示了最终矩阵的状态。任何一个矩阵 `A` 都可以由一个差分矩阵 `b` 通过二维前缀和运算得到，即 `A[i][j] = Σ(b[x][y])` for `1<=x<=i, 1<=y<=j`。
2.  **O(1) 更新**：无论是设置初始值还是执行范围更新，操作都被统一为对差分矩阵 `b` 的四点修改。向子矩阵 `(x1, y1)` 到 `(x2, y2)` 增加值 `c` 的操作，仅需修改 `b[x1][y1]`, `b[x1][y2+1]`, `b[x2+1][y1]`, `b[x2+1][y2+1]` 四个点。这使得每次操作的时间复杂度降至 O(1)。
3.  **初始化即操作**：我们将矩阵的初始值也看作一系列操作。对于每个初始值 `val` 在位置 `(i, j)`，我们执行一次“向子矩阵 `(i,j)` 到 `(i,j)` 增加 `val`”的操作。
4.  **最终还原**：在将初始矩阵和所有 `q` 个查询都“录入”到差分矩阵 `b` 之后，我们通过一次二维前缀和计算，即可从 `b` 中完整地还原出最终矩阵。

*   **时间复杂度**：O(n*m + q)。O(n*m) 用于处理初始矩阵，O(q) 用于处理所有查询，O(n*m) 用于最后的还原。
*   **空间复杂度**：O(n*m)，用于存储统一的差分矩阵。

🔍 实现思路
1.  **数据结构设计**：
    *   仅使用一个 `std::vector<std::vector<long long>>` `b` 作为统一的差分矩阵。为简化边界处理（如 `x2+1`），其维度设为 `(n+2) x (m+2)`，并采用1-based索引。
    *   将四点修改的逻辑封装在一个辅助函数 `insert` 中，以提高代码的清晰度和复用性。

2.  **算法流程**：
    *   **步骤一：初始化**
        *   读取维度 `n, m` 和查询数 `q`。
        *   创建 `(n+2) x (m+2)` 的差分矩阵 `b`，并初始化为全零。
        *   遍历 `i` 从 `1` 到 `n`，`j` 从 `1` 到 `m`，读取初始值 `val`。对于每个 `val`，调用 `insert(b, i, j, i, j, val)`，将其作为一次对单点子矩阵的更新操作应用到差分矩阵 `b` 上。
    *   **步骤二：处理查询**
        *   循环 `q` 次，读取操作参数 `x1, y1, x2, y2, c`。
        *   调用 `insert(b, x1, y1, x2, y2, c)`，将该操作应用到差分矩阵 `b` 上。
    *   **步骤三：还原并输出**
        *   对差分矩阵 `b` 进行一次遍历（从 `(1,1)` 到 `(n,m)`），在遍历过程中原地计算二维前缀和。
        *   计算公式为 `b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1]`。计算后的 `b[i][j]` 即为最终矩阵在该位置的值。
        *   在计算出每个最终值后立即输出，并控制好同行元素间的空格和行尾的换行。

3.  **复杂度分析**：
    *   **时间复杂度**：初始化 O(n*m)，处理查询 O(q)，还原并输出 O(n*m)。总时间复杂度为 O(n*m + q)。
    *   **空间复杂度**：仅需一个差分矩阵 `b`，占用空间为 O(n*m)。

💻 C++11 实现代码
```cpp
#include <iostream> // 引入输入输出流库
#include <vector>   // 引入动态数组 vector

// 辅助函数，用于在差分矩阵上应用一个操作
// 将以 (x1, y1) 为左上角，(x2, y2) 为右下角的子矩阵中所有元素加上 c
// 使用引用传递来直接修改差分矩阵 b
void insert(std::vector<std::vector<long long>>& b, int x1, int y1, int x2, int y2, long long c) {
    b[x1][y1] += c; // 在子矩阵左上角加上 c
    b[x1][y2 + 1] -= c; // 在子矩阵右上角外的第一个位置减去 c
    b[x2 + 1][y1] -= c; // 在子矩阵左下角外的第一个位置减去 c
    b[x2 + 1][y2 + 1] += c; // 在子矩阵右下角外的第一个位置加上 c，补回重复抵消的部分
}

// main 函数是程序的入口点
int main() {
    // 使用 std::ios_base::sync_with_stdio(false) 和 std::cin.tie(NULL) 来加速 C++ 的 I/O 操作
    std::ios_base::sync_with_stdio(false); // 关闭 C++ 流与 C 标准流的同步
    std::cin.tie(NULL); // 解除 cin 和 cout 的绑定

    int n, m, q; // 声明矩阵行数 n，列数 m，以及操作次数 q
    std::cin >> n >> m >> q; // 从标准输入读取 n, m, q

    // 创建一个 (n+2) x (m+2) 的二维 vector 作为统一的差分矩阵，并初始化为0
    // 维度稍大是为了方便处理边界，避免越界
    std::vector<std::vector<long long>> b(n + 2, std::vector<long long>(m + 2, 0));

    // 步骤一：将初始矩阵的值“添加”到差分矩阵中
    // 这相当于对每个初始值 a[i][j] 执行一次对单点子矩阵 (i, j) 的更新操作
    for (int i = 1; i <= n; ++i) { // 遍历每一行
        for (int j = 1; j <= m; ++j) { // 遍历每一列
            long long val; // 声明一个变量存储初始值
            std::cin >> val; // 读取初始矩阵的元素值
            insert(b, i, j, i, j, val); // 将这个初始值作为一次操作应用到差分矩阵
        }
    }

    // 步骤二：处理 q 个更新操作
    for (int k = 0; k < q; ++k) {
        int x1, y1, x2, y2; // 声明子矩阵的左上角和右下角坐标
        long long c; // 声明要增加的值
        std::cin >> x1 >> y1 >> x2 >> y2 >> c; // 读取操作参数
        insert(b, x1, y1, x2, y2, c); // 将这个更新操作应用到差分矩阵
    }

    // 步骤三：通过计算二维前缀和，从差分矩阵还原出最终矩阵并输出
    for (int i = 1; i <= n; ++i) { // 遍历每一行
        for (int j = 1; j <= m; ++j) { // 遍历每一列
            // 当前位置的最终值 = 上方的最终值 + 左边的最终值 - 左上方的最终值 + 当前位置记录的差分值
            // 我们直接在 b 数组上原地计算前缀和，此时 b[i][j] 变为最终值
            b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];
            // 输出计算出的最终值，并根据是否为行末决定是否输出空格
            std::cout << b[i][j] << (j == m ? "" : " ");
        }
        std::cout << std::endl; // 每行结束后换行
    }

    return 0; // 程序正常结束
}
```
