# 2D Difference Array for Toggling

🧠 算法介绍
本算法用于高效解决对二维网格的子区域进行批量“翻转”操作的问题。这里的翻转操作（黑变白、白变黑）本质上等价于对一个计数器进行加1，然后对2取模。

**核心思想**是利用**二维差分**来记录每个格子的翻转次数。我们将棋盘的初始状态（全白）视为翻转次数为0。每次对一个矩形区域 `(x1, y1)` 到 `(x2, y2)` 进行翻转，就等价于将该区域内所有格子的翻转次数加1。这个问题就转化为了经典的“二维差分”问题：对子矩阵进行批量加法操作。

我们维护一个差分矩阵 `b`。对子矩阵 `(x1, y1)` 到 `(x2, y2)` 加1的操作，可以转化为在差分矩阵 `b` 上的四个点的修改：
1.  `b[x1][y1] += 1;`
2.  `b[x1][y2+1] -= 1;`
3.  `b[x2+1][y1] -= 1;`
4.  `b[x2+1][y2+1] += 1;`

在所有 `m` 个操作都记录到差分矩阵 `b` 后，我们通过计算 `b` 的二维前缀和，来得到每个位置 `(i, j)` 的总翻转次数。最终，一个格子的颜色取决于其总翻转次数的奇偶性：若为奇数，则为黑色（1）；若为偶数，则为白色（0）。这等价于将总翻转次数对2取模。

*   **时间复杂度**：O(m + n²)，其中 `m` 是操作次数，`n` 是棋盘边长。`m` 用于处理所有操作（每次O(1)），`n²` 用于最后通过前缀和还原出每个格子的总翻转次数。
*   **空间复杂度**：O(n²)，用于存储差分矩阵。

🔍 实现思路
1.  **数据结构设计**：
    *   使用一个 `std::vector<std::vector<int>>` `b` 作为差分矩阵。虽然翻转次数可能累加得很大，但我们最终只关心其奇偶性，所以使用 `int` 类型足够。
    *   为了方便处理边界情况（如 `x2+1`），差分矩阵 `b` 的维度设为 `(n+2) x (n+2)`，并采用1-based索引，与题目输入保持一致。

2.  **算法流程**：
    *   **步骤一：初始化**
        *   读取棋盘大小 `n` 和操作数 `m`。
        *   创建 `(n+2) x (n+2)` 的差分矩阵 `b`，并初始化所有元素为0。
    *   **步骤二：记录操作**
        *   循环 `m` 次，处理每个翻转操作。
        *   读取矩形坐标 `x1, y1, x2, y2`。
        *   在差分矩阵 `b` 上执行上述的四点修改（加1或减1）。
    *   **步骤三：还原并输出**
        *   遍历棋盘的每个位置（从 `(1,1)` 到 `(n,n)`），在遍历过程中计算二维前缀和，从而得到该位置的总翻转次数。
        *   计算公式为 `b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1]`。
        *   计算出的 `b[i][j]` 就是位置 `(i,j)` 的总翻转次数。最终颜色由 `b[i][j] % 2` 决定。
        *   在计算出每个位置的最终状态后立即输出，并控制好格式。

3.  **复杂度分析**：
    *   **时间复杂度**：初始化 O(n²)。处理 `m` 个操作 O(m)。还原并输出 O(n²)。总时间复杂度为 O(n² + m)。
    *   **空间复杂度**：仅需一个差分矩阵 `b`，占用空间为 O(n²)。

💻 C++11 实现代码
```cpp
#include <iostream> // 引入输入输出流库
#include <vector>   // 引入动态数组 vector

// main 函数是程序的入口点
int main() {
    // 使用 std::ios_base::sync_with_stdio(false) 和 std::cin.tie(NULL) 来加速 C++ 的 I/O 操作
    std::ios_base::sync_with_stdio(false); // 关闭 C++ 流与 C 标准流的同步
    std::cin.tie(NULL); // 解除 cin 和 cout 的绑定

    int n, m; // 声明棋盘大小 n 和操作次数 m
    std::cin >> n >> m; // 从标准输入读取 n, m

    // 创建一个 (n+2) x (n+2) 的二维 vector 作为差分矩阵，并初始化为0
    // 维度稍大是为了方便处理边界，避免在操作时进行额外的坐标检查
    std::vector<std::vector<int>> b(n + 2, std::vector<int>(n + 2, 0));

    // 循环 m 次，处理所有翻转操作
    for (int k = 0; k < m; ++k) {
        int x1, y1, x2, y2; // 声明矩形的左上角和右下角坐标
        std::cin >> x1 >> y1 >> x2 >> y2; // 读取操作参数

        // 在差分矩阵上进行 O(1) 的修改，记录翻转操作
        // 每次翻转相当于翻转次数+1
        b[x1][y1] += 1; // 在子矩阵左上角+1
        b[x1][y2 + 1] -= 1; // 在子矩阵右上角外的第一个位置-1，以抵消多余影响
        b[x2 + 1][y1] -= 1; // 在子矩阵左下角外的第一个位置-1，以抵消多余影响
        b[x2 + 1][y2 + 1] += 1; // 在子矩阵右下角外的第一个位置+1，以补回重复抵消的部分
    }

    // 通过计算二维前缀和，从差分矩阵还原出每个位置的总翻转次数，并输出最终颜色
    for (int i = 1; i <= n; ++i) { // 遍历棋盘的每一行
        for (int j = 1; j <= n; ++j) { // 遍历棋盘的每一列
            // 计算当前位置的总翻转次数
            // b[i][j] 的值 = 上方的总次数 + 左边的总次数 -左上方的总次数 + 当前位置的初始差分值
            b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];

            // 最终颜色取决于总翻转次数的奇偶性
            // 偶数次翻转等于没翻转（白色0），奇数次翻转变为黑色（1）
            // 输出翻转次数对2取模的结果
            std::cout << (b[i][j] % 2);
        }
        std::cout << std::endl; // 每行结束后换行
    }

    return 0; // 程序正常结束
}
```
